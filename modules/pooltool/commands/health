#!/usr/bin/env bash
#NAMESPACE=pooltool::commands

dependencies::register_module "pooltool/commands/health"

# Load required dependencies
bootstrap_load_module pooltool/healthutils
bootstrap_load_module pooltool/driveutils

# Phase 3.1: CLI/Script Mode Enhancement
# Health command with automation-friendly flags and exit codes
#
# Exit codes:
# 0 = Success (all drives healthy)
# 1 = General error (invalid arguments, missing files)
# 2 = Drive not found or inaccessible  
# 3 = Health critical (drive failure detected)
# 4 = Capacity critical (not used in health command)
# 5 = Hardware error (arcconf failure)

# Global flags for output formatting
declare -g HEALTH_QUIET=false
declare -g HEALTH_VERBOSE=false
declare -g HEALTH_JSON=false
declare -g HEALTH_NO_COLOR=false
declare -g HEALTH_EVALUATE=false
declare -g HEALTH_TARGET=""

#-------------------------------------------------------------------------------
# Print health command help
#-------------------------------------------------------------------------------
function health::print_help {
    cat << 'EOF'
USAGE: pooltool health [OPTIONS] [POSITION]

Check drive health status with automation support.

ARGUMENTS:
  POSITION          Drive position number (1-24) to check specific drive
                    (If no position specified, checks all drives)

OPTIONS:
  -q, --quiet       Minimal output for automation scripts
  -v, --verbose     Detailed output for debugging and logging  
  -j, --json        Machine-readable JSON output for integration
  --no-color        Plain text output for log files and scripts
  --evaluate        Analyze all drives and recommend upgrade candidates
  -h, --help        Show this help message

EXIT CODES:
  0                 Success (all drives healthy)
  1                 General error (invalid arguments, missing files)
  2                 Drive not found or inaccessible
  3                 Health critical (drive failure detected)
  5                 Hardware error (arcconf failure)

EXAMPLES:
  pooltool health                      # Check all drives (default)
  pooltool health 5                    # Check drive at position 5
  pooltool health --quiet              # Check all drives, minimal output
  pooltool health 12 --json           # JSON output for position 12
  pooltool health --no-color          # Plain text for logs
  pooltool health --evaluate          # Analyze drives for upgrade candidates

For automation integration, use --quiet --json for minimal, parseable output.
EOF
}

#-------------------------------------------------------------------------------
# Parse command line arguments for health command
#-------------------------------------------------------------------------------
function parse_args {
    local position=""
    local check_all=false
    
    # Reset global flags
    HEALTH_QUIET=false
    HEALTH_VERBOSE=false
    HEALTH_JSON=false
    HEALTH_NO_COLOR=false
    HEALTH_EVALUATE=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                this::health::print_help
                return 255  # Special return code for help
                ;;
            -q|--quiet)
                HEALTH_QUIET=true
                shift
                ;;
            -v|--verbose)
                HEALTH_VERBOSE=true
                shift
                ;;
            -j|--json)
                HEALTH_JSON=true
                shift
                ;;
            --no-color)
                HEALTH_NO_COLOR=true
                shift
                ;;
            --evaluate)
                HEALTH_EVALUATE=true
                shift
                ;;
            --all)
                # Support --all for backward compatibility, but it's now the default
                check_all=true
                shift
                ;;
            [1-9]|[12][0-9]|2[0-4])
                if [[ -n "$position" ]]; then
                    echo "Error: Multiple positions specified" >&2
                    return 1
                fi
                position="$1"
                shift
                ;;
            *)
                echo "Error: Unknown argument '$1'" >&2
                echo "Use 'pooltool health --help' for usage information." >&2
                return 1
                ;;
        esac
    done
    
    # Validate arguments - --all and position are mutually exclusive
    if [[ "$check_all" == true && -n "$position" ]]; then
        echo "Error: Cannot specify both --all and a position" >&2
        return 1
    fi
    
    # Default behavior: if no position specified, check all drives
    if [[ -z "$position" ]]; then
        check_all=true
    fi
    
    # Set global target variable
    if [[ "$check_all" == true ]]; then
        HEALTH_TARGET="all"
    else
        HEALTH_TARGET="$position"
    fi
    
    return 0
}

#-------------------------------------------------------------------------------
# Get drive capacity and usage information
#-------------------------------------------------------------------------------
function health::get_drive_capacity_info {
    local device="$1"
    local mount_name="$2"
    
    # Try to get capacity info from df output for mounted drives
    local df_info=""
    if [[ "$device" != "NONE" && -n "$device" ]]; then
        # Look for mounted partition (typically device + 1, e.g., /dev/sda1)
        df_info=$(df -h "${device}1" 2>/dev/null | tail -n 1)
    fi
    
    # If no df info, try to find by mount name
    if [[ -z "$df_info" && -n "$mount_name" ]]; then
        df_info=$(df -h | grep "/mnt/$mount_name" 2>/dev/null)
    fi
    
    local capacity=""
    local used=""
    local available=""
    local usage_percent=""
    
    if [[ -n "$df_info" ]]; then
        # Parse df output: Filesystem Size Used Avail Use% Mounted
        if [[ "$df_info" =~ ^[^[:space:]]+[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([0-9]+)% ]]; then
            capacity="${BASH_REMATCH[1]}"
            used="${BASH_REMATCH[2]}"
            available="${BASH_REMATCH[3]}"
            usage_percent="${BASH_REMATCH[4]}"
        fi
    fi
    
    # If still no info, try lsblk for device capacity
    if [[ -z "$capacity" && "$device" != "NONE" && -n "$device" ]]; then
        local lsblk_info
        lsblk_info=$(lsblk -b -o SIZE -n "$device" 2>/dev/null | head -n 1)
        if [[ -n "$lsblk_info" ]]; then
            # Convert bytes to human readable
            capacity=$(numfmt --to=iec-i --suffix=B "$lsblk_info" 2>/dev/null | sed 's/B$//')
            usage_percent="0"  # Unknown usage for unmounted drives
        fi
    fi
    
    # Default values if no information found
    [[ -z "$capacity" ]] && capacity="Unknown"
    [[ -z "$used" ]] && used="Unknown"
    [[ -z "$available" ]] && available="Unknown"  
    [[ -z "$usage_percent" ]] && usage_percent="0"
    
    echo "$capacity:$used:$available:$usage_percent"
}

#-------------------------------------------------------------------------------
# Convert capacity to numeric bytes for comparison
#-------------------------------------------------------------------------------
function health::capacity_to_bytes {
    local capacity="$1"
    
    # Remove trailing letters and convert to lowercase
    local size="${capacity%[A-Za-z]*}"
    local unit="${capacity##*[0-9.]}"
    unit=$(echo "$unit" | tr '[:upper:]' '[:lower:]')
    
    # Handle decimal numbers - round to integer
    if [[ ! "$size" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        echo "0"
        return
    fi
    
    # Convert to integer bytes
    local bytes
    case "$unit" in
        k|kb) bytes=$(echo "$size * 1024" | bc 2>/dev/null | cut -d. -f1) ;;
        m|mb) bytes=$(echo "$size * 1024 * 1024" | bc 2>/dev/null | cut -d. -f1) ;;
        g|gb) bytes=$(echo "$size * 1024 * 1024 * 1024" | bc 2>/dev/null | cut -d. -f1) ;;
        t|tb) bytes=$(echo "$size * 1024 * 1024 * 1024 * 1024" | bc 2>/dev/null | cut -d. -f1) ;;
        *) bytes="$size" ;;  # Assume bytes if no unit
    esac
    
    # Ensure we have a valid integer
    if [[ "$bytes" =~ ^[0-9]+$ ]]; then
        echo "$bytes"
    else
        echo "0"
    fi
}

#-------------------------------------------------------------------------------
# Format health status for display
#-------------------------------------------------------------------------------
function format_status {
    local status="$1"
    local use_color="$2"
    
    if [[ "$use_color" == true && "$HEALTH_NO_COLOR" == false ]]; then
        case "$status" in
            "good") echo "✅ Healthy" ;;
            "warning") echo "⚠️  Warning" ;;
            "critical") echo "❌ Critical" ;;
            *) echo "❓ Unknown" ;;
        esac
    else
        case "$status" in
            "good") echo "Healthy" ;;
            "warning") echo "Warning" ;;
            "critical") echo "Critical" ;;
            *) echo "Unknown" ;;
        esac
    fi
}

#-------------------------------------------------------------------------------
# Get health data for a single drive
#-------------------------------------------------------------------------------
function get_drive_health_data {
    local position="$1"
    local main_controller="$2"
    local unified_array=("${@:3}")
    
    local drive_found=false
    local health_data=""
    
    # Search for drive at specified position
    for unified_entry in "${unified_array[@]}"; do
        if [[ "$unified_entry" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
            local mount_name="${BASH_REMATCH[1]}"
            local snapraid_name="${BASH_REMATCH[2]}"
            local rec_connector="${BASH_REMATCH[3]}"
            local rec_device="${BASH_REMATCH[4]}"
            local mount_path="${BASH_REMATCH[5]}"
            local system_device="${BASH_REMATCH[6]}"
            local controller="${BASH_REMATCH[7]}"
            local arcconf_position="${BASH_REMATCH[8]}"
            
            # Calculate position using the same logic as select command
            local calc_position=$(( rec_connector * 4 + (4 - rec_device) ))
            
            if [[ "$calc_position" == "$position" ]]; then
                drive_found=true
                
                # Get health information
                if [[ "$system_device" != "N/A" ]]; then
                    health_data=$(pooltool::get_drive_health "$system_device" "$main_controller")
                    if [[ "$health_data" =~ ^([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
                        echo "found:$position:$system_device:$mount_name:$mount_path:$health_data"
                        return 0
                    else
                        echo "error:$position:$system_device:$snapraid_name:$mount_path:Unable to retrieve health data"
                        return 5
                    fi
                else
                    echo "unavailable:$position:N/A:$mount_name:$mount_path:Drive not accessible"
                    return 2
                fi
            fi
        fi
    done
    
    if [[ "$drive_found" == false ]]; then
        echo "notfound:$position:N/A:N/A:N/A:Drive not found at position $position"
        return 2
    fi
}

#-------------------------------------------------------------------------------
# Output single drive health in JSON format
#-------------------------------------------------------------------------------
function output_json_single {
    local result="$1"
    
    if [[ "$result" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):(.*)$ ]]; then
        local status="${BASH_REMATCH[1]}"
        local position="${BASH_REMATCH[2]}"
        local device="${BASH_REMATCH[3]}"
        local snapraid="${BASH_REMATCH[4]}"
        local mount="${BASH_REMATCH[5]}"
        local health_info="${BASH_REMATCH[6]}"
        
        echo "{"
        echo "  \"position\": $position,"
        echo "  \"device\": \"$device\","
        echo "  \"snapraid_name\": \"$snapraid\","
        echo "  \"mount_path\": \"$mount\","
        
        if [[ "$status" == "found" && "$health_info" =~ ^([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
            local health_status="${BASH_REMATCH[1]}"
            local temperature="${BASH_REMATCH[2]}"
            local power_hours="${BASH_REMATCH[3]}"
            local power_cycles="${BASH_REMATCH[4]}"
            
            echo "  \"status\": \"$health_status\","
            echo "  \"temperature_celsius\": $temperature,"
            echo "  \"power_on_hours\": $power_hours,"
            echo "  \"power_cycles\": $power_cycles,"
            echo "  \"accessible\": true"
        else
            echo "  \"status\": \"unknown\","
            echo "  \"error\": \"$health_info\","
            echo "  \"accessible\": false"
        fi
        
        echo "}"
    fi
}

#-------------------------------------------------------------------------------
# Output single drive health in standard format
#-------------------------------------------------------------------------------
function output_standard_single {
    local result="$1"
    
    if [[ "$result" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):(.*)$ ]]; then
        local status="${BASH_REMATCH[1]}"
        local position="${BASH_REMATCH[2]}"
        local device="${BASH_REMATCH[3]}"
        local snapraid="${BASH_REMATCH[4]}"
        local mount="${BASH_REMATCH[5]}"
        local health_info="${BASH_REMATCH[6]}"
        
        if [[ "$HEALTH_QUIET" == false ]]; then
            echo "🏥 HEALTH CHECK FOR POSITION $position"
            echo "═══════════════════════════════════"
        fi
        
        if [[ "$status" == "found" && "$health_info" =~ ^([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
            local health_status="${BASH_REMATCH[1]}"
            local temperature="${BASH_REMATCH[2]}"
            local power_hours="${BASH_REMATCH[3]}"
            local power_cycles="${BASH_REMATCH[4]}"
            
            local status_display=$(this::format_status "$health_status" true)
            
            if [[ "$HEALTH_QUIET" == true ]]; then
                echo "Position $position: $health_status"
            else
                printf "  %-20s %s\n" "Position:" "$position"
                printf "  %-20s %s\n" "Device:" "$device"
                printf "  %-20s %s\n" "SnapRAID Name:" "$snapraid"
                printf "  %-20s %s\n" "Mount Path:" "$mount"
                printf "  %-20s %s\n" "Health Status:" "$status_display"
                printf "  %-20s %s°C\n" "Temperature:" "$temperature"
                printf "  %-20s %s hours\n" "Power-On Time:" "$power_hours"
                printf "  %-20s %s cycles\n" "Power Cycles:" "$power_cycles"
                
                if [[ "$HEALTH_VERBOSE" == true ]]; then
                    echo
                    echo "  Health Assessment:"
                    case "$health_status" in
                        "good")
                            echo "  • Drive is operating normally"
                            echo "  • All SMART parameters within acceptable ranges"
                            ;;
                        "warning")
                            echo "  • Drive shows warning indicators"
                            echo "  • Monitor closely and consider replacement"
                            ;;
                        "critical")
                            echo "  • Drive failure imminent or detected"
                            echo "  • Immediate replacement recommended"
                            ;;
                    esac
                fi
            fi
        else
            if [[ "$HEALTH_QUIET" == true ]]; then
                echo "Position $position: error ($health_info)"
            else
                printf "  %-20s %s\n" "Position:" "$position"
                printf "  %-20s %s\n" "Status:" "⚠️  $health_info"
            fi
        fi
        
        if [[ "$HEALTH_QUIET" == false ]]; then
            echo
        fi
    fi
}

#-------------------------------------------------------------------------------
# Evaluate all drives and recommend upgrade candidates
#-------------------------------------------------------------------------------
function health::evaluate_drives {
    local controller="$1"
    
    if [[ "$HEALTH_QUIET" == false ]]; then
        echo "🔍 DRIVE EVALUATION ANALYSIS"
        echo "═══════════════════════════"
        echo
    fi
    
    # Get unified device data
    local unified_data
    unified_data=$(pooltool::create_unified_mapping "$controller" 2>/dev/null)
    if [[ -z "$unified_data" ]]; then
        echo "Error: Unable to retrieve system data" >&2
        return 5
    fi
    
    mapfile -t unified_array <<< "$unified_data"
    
    # Get health data for all drives
    local health_results
    if ! health_results=$(pooltool::get_all_health_info_efficient "$controller" "${unified_array[@]}" 2>/dev/null); then
        echo "Error: Unable to retrieve health data for drives" >&2
        return 5
    fi
    
    # Analyze each drive and create evaluation results
    local evaluation_results=()
    local critical_count=0
    local warning_count=0
    local upgrade_candidates=()
    
    while IFS= read -r line; do
        if [[ -n "$line" && "$line" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
            local mount_name="${BASH_REMATCH[1]}"
            local snapraid_name="${BASH_REMATCH[2]}"
            local rec_connector="${BASH_REMATCH[3]}"
            local rec_device="${BASH_REMATCH[4]}"
            local mount_path="${BASH_REMATCH[5]}"
            local system_device="${BASH_REMATCH[6]}"
            local controller="${BASH_REMATCH[7]}"
            local arcconf_position="${BASH_REMATCH[8]}"
            local health_status="${BASH_REMATCH[14]}"
            local temperature="${BASH_REMATCH[15]}"
            local power_hours="${BASH_REMATCH[16]}"
            local reallocated_sectors="${BASH_REMATCH[17]}"
            
            # Calculate position using the same logic as select command
            local calc_position=$(( rec_connector * 4 + (4 - rec_device) ))
            
            # Calculate risk score (0-100, higher is worse)
            local risk_score=0
            local risk_factors=()
            local recommendation=""
            
            # Age analysis (power on hours)
            if [[ "$power_hours" =~ ^[0-9]+$ ]]; then
                local age_years=$((power_hours / 8760))  # Approximate years based on 24/7 operation
                if [[ $power_hours -gt 70000 ]]; then
                    risk_score=$((risk_score + 40))
                    risk_factors+=("Very high age: ${age_years}+ years")
                elif [[ $power_hours -gt 50000 ]]; then
                    risk_score=$((risk_score + 25))
                    risk_factors+=("High age: ${age_years}+ years")
                elif [[ $power_hours -gt 30000 ]]; then
                    risk_score=$((risk_score + 10))
                    risk_factors+=("Moderate age: ${age_years}+ years")
                fi
            fi
            
            # Health status analysis
            case "$health_status" in
                "critical")
                    risk_score=$((risk_score + 50))
                    risk_factors+=("Critical SMART status")
                    critical_count=$((critical_count + 1))
                    recommendation="URGENT: Replace immediately"
                    ;;
                "warning")
                    risk_score=$((risk_score + 30))
                    risk_factors+=("Warning SMART status")
                    warning_count=$((warning_count + 1))
                    ;;
                "good")
                    # No penalty for good health
                    ;;
            esac
            
            # Temperature analysis  
            if [[ "$temperature" =~ ^[0-9]+$ ]]; then
                if [[ $temperature -gt 50 ]]; then
                    risk_score=$((risk_score + 20))
                    risk_factors+=("High temperature: ${temperature}°C")
                elif [[ $temperature -gt 45 ]]; then
                    risk_score=$((risk_score + 10))
                    risk_factors+=("Elevated temperature: ${temperature}°C")
                fi
            fi
            
            # Get capacity and usage information
            local capacity_info
            capacity_info=$(this::health::get_drive_capacity_info "$system_device" "$mount_name")
            local capacity used available usage_percent
            IFS=':' read -r capacity used available usage_percent <<< "$capacity_info"
            
            # Capacity and usage analysis
            local capacity_bytes
            capacity_bytes=$(this::health::capacity_to_bytes "$capacity")
            
            # Size-based scoring (smaller drives get higher risk for upgrade value)
            if [[ "$capacity_bytes" != "0" && "$capacity" != "Unknown" ]]; then
                local tb_size=$((capacity_bytes / (1024*1024*1024*1024)))
                if [[ $tb_size -lt 4 ]]; then
                    risk_score=$((risk_score + 25))
                    risk_factors+=("Small capacity: $capacity")
                elif [[ $tb_size -lt 8 ]]; then
                    risk_score=$((risk_score + 15))
                    risk_factors+=("Limited capacity: $capacity")
                elif [[ $tb_size -lt 12 ]]; then
                    risk_score=$((risk_score + 5))
                    risk_factors+=("Moderate capacity: $capacity")
                fi
            fi
            
            # Usage-based scoring (high utilization increases upgrade priority)
            if [[ "$usage_percent" =~ ^[0-9]+$ ]]; then
                if [[ $usage_percent -gt 95 ]]; then
                    risk_score=$((risk_score + 20))
                    risk_factors+=("Very high usage: ${usage_percent}%")
                elif [[ $usage_percent -gt 90 ]]; then
                    risk_score=$((risk_score + 15))
                    risk_factors+=("High usage: ${usage_percent}%")
                elif [[ $usage_percent -gt 80 ]]; then
                    risk_score=$((risk_score + 10))
                    risk_factors+=("Elevated usage: ${usage_percent}%")
                fi
            fi
            
            # Reallocated sectors analysis
            if [[ "$reallocated_sectors" =~ ^[0-9]+$ && $reallocated_sectors -gt 0 ]]; then
                if [[ $reallocated_sectors -gt 10 ]]; then
                    risk_score=$((risk_score + 30))
                    risk_factors+=("High reallocated sectors: $reallocated_sectors")
                elif [[ $reallocated_sectors -gt 0 ]]; then
                    risk_score=$((risk_score + 15))
                    risk_factors+=("Reallocated sectors: $reallocated_sectors")
                fi
            fi
            
            # Determine overall recommendation
            if [[ -z "$recommendation" ]]; then
                if [[ $risk_score -ge 60 ]]; then
                    recommendation="High priority upgrade candidate"
                    upgrade_candidates+=("$calc_position:$risk_score:$mount_name")
                elif [[ $risk_score -ge 35 ]]; then
                    recommendation="Consider for future upgrade"
                    upgrade_candidates+=("$calc_position:$risk_score:$mount_name")
                elif [[ $risk_score -ge 15 ]]; then
                    recommendation="Monitor closely"
                else
                    recommendation="Good condition"
                fi
            fi
            
            # Store evaluation result (including capacity information)
            local risk_factors_str=""
            if [[ ${#risk_factors[@]} -gt 0 ]]; then
                risk_factors_str=$(IFS='; '; echo "${risk_factors[*]}")
            else
                risk_factors_str="None identified"
            fi
            
            evaluation_results+=("$calc_position:$mount_name:$system_device:$health_status:$temperature:$power_hours:$capacity:$used:$available:$usage_percent:$risk_score:$recommendation:$risk_factors_str")
        fi
    done <<< "$health_results"
    
    # Sort results by risk score (highest first)
    local sorted_results=()
    IFS=$'\n' sorted_results=($(printf '%s\n' "${evaluation_results[@]}" | sort -t: -k11 -nr))
    unset IFS
    
    # Output results
    if [[ "$HEALTH_JSON" == true ]]; then
        echo "{"
        echo "  \"evaluation_timestamp\": \"$(date -Iseconds)\","
        echo "  \"summary\": {"
        echo "    \"total_drives\": ${#evaluation_results[@]},"
        echo "    \"critical_drives\": $critical_count,"
        echo "    \"warning_drives\": $warning_count,"
        echo "    \"upgrade_candidates\": ${#upgrade_candidates[@]}"
        echo "  },"
        echo "  \"drives\": ["
        
        for i in "${!sorted_results[@]}"; do
            local result="${sorted_results[$i]}"
            if [[ "$result" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):(.*)$ ]]; then
                local position="${BASH_REMATCH[1]}"
                local mount_name="${BASH_REMATCH[2]}"
                local device="${BASH_REMATCH[3]}"
                local health_status="${BASH_REMATCH[4]}"
                local temperature="${BASH_REMATCH[5]}"
                local power_hours="${BASH_REMATCH[6]}"
                local capacity="${BASH_REMATCH[7]}"
                local used="${BASH_REMATCH[8]}"
                local available="${BASH_REMATCH[9]}"
                local usage_percent="${BASH_REMATCH[10]}"
                local risk_score="${BASH_REMATCH[11]}"
                local recommendation="${BASH_REMATCH[12]}"
                local risk_factors="${BASH_REMATCH[13]}"
                
                echo "    {"
                echo "      \"position\": $position,"
                echo "      \"mount_name\": \"$mount_name\","
                echo "      \"device\": \"$device\","
                echo "      \"health_status\": \"$health_status\","
                echo "      \"temperature_celsius\": $temperature,"
                echo "      \"power_on_hours\": $power_hours,"
                echo "      \"capacity\": \"$capacity\","
                echo "      \"used_space\": \"$used\","
                echo "      \"available_space\": \"$available\","
                echo "      \"usage_percent\": $usage_percent,"
                echo "      \"risk_score\": $risk_score,"
                echo "      \"recommendation\": \"$recommendation\","
                echo "      \"risk_factors\": \"$risk_factors\""
                if [[ $i -lt $((${#sorted_results[@]} - 1)) ]]; then
                    echo "    },"
                else
                    echo "    }"
                fi
            fi
        done
        
        echo "  ]"
        echo "}"
    else
        # Standard output format
        for result in "${sorted_results[@]}"; do
            if [[ "$result" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):(.*)$ ]]; then
                local position="${BASH_REMATCH[1]}"
                local mount_name="${BASH_REMATCH[2]}"
                local device="${BASH_REMATCH[3]}"
                local health_status="${BASH_REMATCH[4]}"
                local temperature="${BASH_REMATCH[5]}"
                local power_hours="${BASH_REMATCH[6]}"
                local capacity="${BASH_REMATCH[7]}"
                local used="${BASH_REMATCH[8]}"
                local available="${BASH_REMATCH[9]}"
                local usage_percent="${BASH_REMATCH[10]}"
                local risk_score="${BASH_REMATCH[11]}"
                local recommendation="${BASH_REMATCH[12]}"
                local risk_factors="${BASH_REMATCH[13]}"
                
                local age_years=$((power_hours / 8760))
                
                # Color coding for risk score
                local risk_icon=""
                local rec_color=""
                if [[ "$HEALTH_NO_COLOR" == false ]]; then
                    case "$health_status" in
                        "critical") rec_color="❌" ;;
                        "warning") rec_color="⚠️" ;;
                        *) rec_color="✅" ;;
                    esac
                    
                    if [[ $risk_score -ge 60 ]]; then
                        risk_icon="🔴"
                    elif [[ $risk_score -ge 35 ]]; then
                        risk_icon="🟡"
                    else
                        risk_icon="🟢"
                    fi
                fi
                
                if [[ "$HEALTH_QUIET" == false ]]; then
                    echo "${risk_icon} Position $position ($mount_name) - Risk Score: $risk_score/100"
                    printf "  %-20s %s\n" "Device:" "$device"
                    printf "  %-20s %s %s\n" "Health Status:" "$rec_color" "$health_status"
                    printf "  %-20s %s°C\n" "Temperature:" "$temperature"
                    printf "  %-20s %s hours (~%s years)\n" "Power-On Time:" "$power_hours" "$age_years"
                    if [[ "$capacity" != "Unknown" ]]; then
                        printf "  %-20s %s\n" "Capacity:" "$capacity"
                        if [[ "$used" != "Unknown" && "$usage_percent" != "0" ]]; then
                            printf "  %-20s %s used, %s free (%s%% used)\n" "Usage:" "$used" "$available" "$usage_percent"
                        fi
                    fi
                    printf "  %-20s %s\n" "Recommendation:" "$recommendation"
                    printf "  %-20s %s\n" "Risk Factors:" "$risk_factors"
                    echo
                else
                    local capacity_info=""
                    if [[ "$capacity" != "Unknown" ]]; then
                        capacity_info=" - $capacity"
                        if [[ "$usage_percent" != "0" ]]; then
                            capacity_info="$capacity_info (${usage_percent}% used)"
                        fi
                    fi
                    echo "Position $position: Risk $risk_score - $recommendation$capacity_info"
                fi
            fi
        done
        
        if [[ "$HEALTH_QUIET" == false ]]; then
            echo "📊 EVALUATION SUMMARY"
            echo "══════════════════"
            echo "Total drives analyzed: ${#evaluation_results[@]}"
            echo "Critical drives: $critical_count"
            echo "Warning drives: $warning_count"
            echo "Upgrade candidates: ${#upgrade_candidates[@]}"
            
            if [[ ${#upgrade_candidates[@]} -gt 0 ]]; then
                echo
                echo "🎯 TOP UPGRADE CANDIDATES:"
                for candidate in "${upgrade_candidates[@]}"; do
                    if [[ "$candidate" =~ ^([^:]+):([^:]+):(.*)$ ]]; then
                        local pos="${BASH_REMATCH[1]}"
                        local score="${BASH_REMATCH[2]}"
                        local name="${BASH_REMATCH[3]}"
                        echo "  Position $pos ($name) - Risk Score: $score"
                    fi
                done
            fi
        fi
    fi
    
    # Return exit code based on findings
    if [[ $critical_count -gt 0 ]]; then
        return 3
    elif [[ $warning_count -gt 0 || ${#upgrade_candidates[@]} -gt 0 ]]; then
        return 1
    else
        return 0
    fi
}

#-------------------------------------------------------------------------------
# Main health command function
#-------------------------------------------------------------------------------
function health {
    # Parse arguments
    if ! this::parse_args "$@"; then
        local parse_exit_code=$?
        if [[ $parse_exit_code -eq 255 ]]; then
            # Help was shown, exit successfully
            exit 0
        else
            # Error in arguments
            exit 1
        fi
    fi
    
    # If evaluation mode is requested, run drive evaluation and exit
    if [[ "$HEALTH_EVALUATE" == true ]]; then
        this::health::evaluate_drives "$controller"
        exit $?
    fi
    
    local target="$HEALTH_TARGET"
    local controller="${POOLTOOL_CONTROLLER:-1}"
    local exit_code=0
    local critical_found=false
    
    # Get unified device data
    local unified_data
    unified_data=$(pooltool::create_unified_mapping "$controller" 2>/dev/null)
    if [[ -z "$unified_data" ]]; then
        if [[ "$HEALTH_JSON" == true ]]; then
            echo '{"error": "Unable to retrieve system data", "accessible": false}'
        else
            echo "Error: Unable to retrieve system data" >&2
        fi
        exit 5
    fi
    
    mapfile -t unified_array <<< "$unified_data"
    
    if [[ "$target" == "all" ]]; then
        # Check all drives efficiently using bulk health collection
        local health_results
        if ! health_results=$(pooltool::get_all_health_info_efficient "$controller" "${unified_array[@]}" 2>/dev/null); then
            if [[ "$HEALTH_JSON" == true ]]; then
                echo '{"error": "Unable to retrieve health data", "accessible": false}'
            else
                echo "Error: Unable to retrieve health data for drives" >&2
            fi
            exit 5
        fi
        
        local results=()
        local positions=()
        
        # Parse the bulk health results and convert to our format
        while IFS= read -r line; do
            if [[ "$line" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
                local mount_name="${BASH_REMATCH[1]}"
                local snapraid_name="${BASH_REMATCH[2]}"
                local rec_connector="${BASH_REMATCH[3]}"
                local rec_device="${BASH_REMATCH[4]}"
                local mount_path="${BASH_REMATCH[5]}"
                local system_device="${BASH_REMATCH[6]}"
                local health_status="${BASH_REMATCH[14]}"
                local temperature="${BASH_REMATCH[15]}"
                local power_hours="${BASH_REMATCH[16]}"
                local reallocated_sectors="${BASH_REMATCH[17]}"
                
                # Calculate position using the same logic as select command
                local calc_position=$(( rec_connector * 4 + (4 - rec_device) ))
                positions+=("$calc_position")
                
                # Format health data like get_drive_health_data output
                local health_data="$health_status:$temperature:$power_hours:$reallocated_sectors"
                local result="found:$calc_position:$system_device:$mount_name:$mount_path:$health_data"
                results+=("$result")
                
                # Check for critical status
                if [[ "$health_status" == "critical" ]]; then
                    critical_found=true
                fi
                
                # Track exit codes - warning and critical should return appropriate codes
                case "$health_status" in
                    "critical") exit_code=3 ;;
                    "warning") [[ $exit_code -lt 1 ]] && exit_code=1 ;;
                esac
            fi
        done <<< "$health_results"
        
        # Sort results by position for consistent output
        local sorted_results=()
        IFS=$'\n' sorted_positions=($(printf '%s\n' "${positions[@]}" | sort -n))
        unset IFS
        
        for pos in "${sorted_positions[@]}"; do
            for result in "${results[@]}"; do
                if [[ "$result" =~ ^found:$pos: ]]; then
                    sorted_results+=("$result")
                    break
                fi
            done
        done
        results=("${sorted_results[@]}")
        
        # Output results
        if [[ "$HEALTH_JSON" == true ]]; then
            echo "{"
            echo "  \"drives\": ["
            for i in "${!results[@]}"; do
                echo -n "    "
                this::output_json_single "${results[$i]}"
                if [[ $i -lt $((${#results[@]} - 1)) ]]; then
                    echo ","
                else
                    echo
                fi
            done
            echo "  ],"
            echo "  \"summary\": {"
            echo "    \"total_drives\": ${#results[@]},"
            echo "    \"critical_found\": $critical_found"
            echo "  }"
            echo "}"
        else
            if [[ "$HEALTH_QUIET" == false ]]; then
                echo "🏥 SYSTEM HEALTH CHECK"
                echo "════════════════════"
                echo
            fi
            
            for result in "${results[@]}"; do
                this::output_standard_single "$result"
            done
            
            if [[ "$HEALTH_QUIET" == false ]]; then
                echo "Health check complete for ${#results[@]} drives."
                if [[ "$critical_found" == true ]]; then
                    echo "⚠️  Critical drives detected - immediate attention required!"
                fi
            fi
        fi
        
    else
        # Check single drive
        local result
        result=$(this::get_drive_health_data "$target" "$controller" "${unified_array[@]}")
        exit_code=$?
        
        if [[ "$HEALTH_JSON" == true ]]; then
            this::output_json_single "$result"
        else
            this::output_standard_single "$result"
        fi
        
        # Check for critical status
        if [[ "$result" =~ :critical: ]]; then
            exit_code=3
        fi
    fi
    
    exit $exit_code
}
