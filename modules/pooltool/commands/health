#!/usr/bin/env bash
#NAMESPACE=pooltool::commands

dependencies::register_module "pooltool/commands/health"

# Load required dependencies
bootstrap_load_module pooltool/healthutils
bootstrap_load_module pooltool/driveutils

# Phase 3.1: CLI/Script Mode Enhancement
# Health command with automation-friendly flags and exit codes
#
# Exit codes:
# 0 = Success (all drives healthy)
# 1 = General error (invalid arguments, missing files)
# 2 = Drive not found or inaccessible  
# 3 = Health critical (drive failure detected)
# 4 = Capacity critical (not used in health command)
# 5 = Hardware error (arcconf failure)

# Global flags for output formatting
declare -g HEALTH_QUIET=false
declare -g HEALTH_VERBOSE=false
declare -g HEALTH_JSON=false
declare -g HEALTH_NO_COLOR=false
declare -g HEALTH_TARGET=""

#-------------------------------------------------------------------------------
# Print health command help
#-------------------------------------------------------------------------------
function print_help {
    cat << 'EOF'
USAGE: pooltool health [OPTIONS] [POSITION]

Check drive health status with automation support.

ARGUMENTS:
  POSITION          Drive position number (1-24) to check specific drive
                    (If no position specified, checks all drives)

OPTIONS:
  -q, --quiet       Minimal output for automation scripts
  -v, --verbose     Detailed output for debugging and logging  
  -j, --json        Machine-readable JSON output for integration
  --no-color        Plain text output for log files and scripts
  -h, --help        Show this help message

EXIT CODES:
  0                 Success (all drives healthy)
  1                 General error (invalid arguments, missing files)
  2                 Drive not found or inaccessible
  3                 Health critical (drive failure detected)
  5                 Hardware error (arcconf failure)

EXAMPLES:
  pooltool health                      # Check all drives (default)
  pooltool health 5                    # Check drive at position 5
  pooltool health --quiet              # Check all drives, minimal output
  pooltool health 12 --json           # JSON output for position 12
  pooltool health --no-color          # Plain text for logs

For automation integration, use --quiet --json for minimal, parseable output.
EOF
}

#-------------------------------------------------------------------------------
# Parse command line arguments for health command
#-------------------------------------------------------------------------------
function parse_args {
    local position=""
    local check_all=false
    
    # Reset global flags
    HEALTH_QUIET=false
    HEALTH_VERBOSE=false
    HEALTH_JSON=false
    HEALTH_NO_COLOR=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                this::print_help
                return 255  # Special return code for help
                ;;
            -q|--quiet)
                HEALTH_QUIET=true
                shift
                ;;
            -v|--verbose)
                HEALTH_VERBOSE=true
                shift
                ;;
            -j|--json)
                HEALTH_JSON=true
                shift
                ;;
            --no-color)
                HEALTH_NO_COLOR=true
                shift
                ;;
            --all)
                # Support --all for backward compatibility, but it's now the default
                check_all=true
                shift
                ;;
            [1-9]|[12][0-9]|2[0-4])
                if [[ -n "$position" ]]; then
                    echo "Error: Multiple positions specified" >&2
                    return 1
                fi
                position="$1"
                shift
                ;;
            *)
                echo "Error: Unknown argument '$1'" >&2
                echo "Use 'pooltool health --help' for usage information." >&2
                return 1
                ;;
        esac
    done
    
    # Validate arguments - --all and position are mutually exclusive
    if [[ "$check_all" == true && -n "$position" ]]; then
        echo "Error: Cannot specify both --all and a position" >&2
        return 1
    fi
    
    # Default behavior: if no position specified, check all drives
    if [[ -z "$position" ]]; then
        check_all=true
    fi
    
    # Set global target variable
    if [[ "$check_all" == true ]]; then
        HEALTH_TARGET="all"
    else
        HEALTH_TARGET="$position"
    fi
    
    return 0
}

#-------------------------------------------------------------------------------
# Format health status for display
#-------------------------------------------------------------------------------
function format_status {
    local status="$1"
    local use_color="$2"
    
    if [[ "$use_color" == true && "$HEALTH_NO_COLOR" == false ]]; then
        case "$status" in
            "good") echo "✅ Healthy" ;;
            "warning") echo "⚠️  Warning" ;;
            "critical") echo "❌ Critical" ;;
            *) echo "❓ Unknown" ;;
        esac
    else
        case "$status" in
            "good") echo "Healthy" ;;
            "warning") echo "Warning" ;;
            "critical") echo "Critical" ;;
            *) echo "Unknown" ;;
        esac
    fi
}

#-------------------------------------------------------------------------------
# Get health data for a single drive
#-------------------------------------------------------------------------------
function get_drive_health_data {
    local position="$1"
    local main_controller="$2"
    local unified_array=("${@:3}")
    
    local drive_found=false
    local health_data=""
    
    # Search for drive at specified position
    for unified_entry in "${unified_array[@]}"; do
        if [[ "$unified_entry" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
            local mount_name="${BASH_REMATCH[1]}"        # DRU03, NEW-14T, etc.
            local position_field="${BASH_REMATCH[2]}"    # Position number
            local rec_connector="${BASH_REMATCH[3]}"     # Connector
            local rec_device="${BASH_REMATCH[4]}"        # Device slot
            local snapraid_role="${BASH_REMATCH[5]}"     # data3, parity, NONE
            local system_device="${BASH_REMATCH[6]}"     # /dev/sdd or NONE
            local wwn="${BASH_REMATCH[7]}"               # WWN
            local serial="${BASH_REMATCH[8]}"            # Serial number
            local channel="${BASH_REMATCH[9]}"           # Channel
            local device_num="${BASH_REMATCH[10]}"       # Device number  
            local model="${BASH_REMATCH[11]}"            # Drive model
            local size="${BASH_REMATCH[12]}"             # Drive size
            local type="${BASH_REMATCH[13]}"             # Type/status
            
            # Mount path for SnapRAID drives
            local mount_path=""
            if [[ "$snapraid_role" != "NONE" ]]; then
                mount_path="/mnt/$mount_name"
            fi
            
            # Calculate position using the same logic as select command
            local calc_position=$(( rec_connector * 4 + (4 - rec_device) ))
            
            if [[ "$calc_position" == "$position" ]]; then
                drive_found=true
                
                # Get health information
                if [[ "$system_device" != "NONE" && "$system_device" != "N/A" ]]; then
                    health_data=$(pooltool::get_drive_health "$system_device" "$main_controller")
                    if [[ "$health_data" =~ ^([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
                        # Format: found:position:device:name_or_role:mount_or_type:health_data
                        if [[ "$snapraid_role" == "NONE" ]]; then
                            echo "found:$position:$system_device:$mount_name:unallocated:$health_data"
                        else
                            echo "found:$position:$system_device:$snapraid_role:$mount_path:$health_data"
                        fi
                        return 0
                    else
                        if [[ "$snapraid_role" == "NONE" ]]; then
                            echo "error:$position:$system_device:$mount_name:unallocated:Unable to retrieve health data"
                        else
                            echo "error:$position:$system_device:$snapraid_role:$mount_path:Unable to retrieve health data"
                        fi
                        return 5
                    fi
                else
                    if [[ "$snapraid_role" == "NONE" ]]; then
                        echo "unavailable:$position:NONE:$mount_name:unallocated:Drive not accessible"
                    else
                        echo "unavailable:$position:NONE:$snapraid_role:$mount_path:Drive not accessible"
                    fi
                    return 2
                fi
            fi
        fi
    done
    
    if [[ "$drive_found" == false ]]; then
        echo "notfound:$position:N/A:N/A:N/A:Drive not found at position $position"
        return 2
    fi
}

#-------------------------------------------------------------------------------
# Output single drive health in JSON format
#-------------------------------------------------------------------------------
function output_json_single {
    local result="$1"
    
    if [[ "$result" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):(.*)$ ]]; then
        local status="${BASH_REMATCH[1]}"
        local position="${BASH_REMATCH[2]}"
        local device="${BASH_REMATCH[3]}"
        local snapraid="${BASH_REMATCH[4]}"
        local mount="${BASH_REMATCH[5]}"
        local health_info="${BASH_REMATCH[6]}"
        
        echo "{"
        echo "  \"position\": $position,"
        echo "  \"device\": \"$device\","
        
        if [[ "$mount" == "unallocated" ]]; then
            echo "  \"drive_name\": \"$snapraid\","
            echo "  \"status_type\": \"unallocated\","
            echo "  \"in_snapraid\": false,"
        else
            echo "  \"snapraid_role\": \"$snapraid\","
            echo "  \"mount_path\": \"$mount\","
            echo "  \"in_snapraid\": true,"
        fi
        
        if [[ "$status" == "found" && "$health_info" =~ ^([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
            local health_status="${BASH_REMATCH[1]}"
            local temperature="${BASH_REMATCH[2]}"
            local power_hours="${BASH_REMATCH[3]}"
            local power_cycles="${BASH_REMATCH[4]}"
            
            echo "  \"status\": \"$health_status\","
            echo "  \"temperature_celsius\": $temperature,"
            echo "  \"power_on_hours\": $power_hours,"
            echo "  \"power_cycles\": $power_cycles,"
            echo "  \"accessible\": true"
        else
            echo "  \"status\": \"unknown\","
            echo "  \"error\": \"$health_info\","
            echo "  \"accessible\": false"
        fi
        
        echo "}"
    fi
}

#-------------------------------------------------------------------------------
# Output single drive health in standard format
#-------------------------------------------------------------------------------
function output_standard_single {
    local result="$1"
    
    if [[ "$result" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):(.*)$ ]]; then
        local status="${BASH_REMATCH[1]}"
        local position="${BASH_REMATCH[2]}"
        local device="${BASH_REMATCH[3]}"
        local snapraid="${BASH_REMATCH[4]}"
        local mount="${BASH_REMATCH[5]}"
        local health_info="${BASH_REMATCH[6]}"
        
        if [[ "$HEALTH_QUIET" == false ]]; then
            echo "🏥 HEALTH CHECK FOR POSITION $position"
            echo "═══════════════════════════════════"
        fi
        
        if [[ "$status" == "found" && "$health_info" =~ ^([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
            local health_status="${BASH_REMATCH[1]}"
            local temperature="${BASH_REMATCH[2]}"
            local power_hours="${BASH_REMATCH[3]}"
            local power_cycles="${BASH_REMATCH[4]}"
            
            local status_display=$(this::format_status "$health_status" true)
            
            if [[ "$HEALTH_QUIET" == true ]]; then
                echo "Position $position: $health_status"
            else
                printf "  %-20s %s\n" "Position:" "$position"
                printf "  %-20s %s\n" "Device:" "$device"
                
                # Show appropriate label based on whether drive is in SnapRAID array
                if [[ "$mount" == "unallocated" ]]; then
                    printf "  %-20s %s\n" "Drive Name:" "$snapraid"
                    printf "  %-20s %s\n" "Status:" "Unallocated (not in SnapRAID)"
                else
                    printf "  %-20s %s\n" "SnapRAID Role:" "$snapraid"
                    printf "  %-20s %s\n" "Mount Path:" "$mount"
                fi
                
                printf "  %-20s %s\n" "Health Status:" "$status_display"
                printf "  %-20s %s°C\n" "Temperature:" "$temperature"
                printf "  %-20s %s hours\n" "Power-On Time:" "$power_hours"
                printf "  %-20s %s cycles\n" "Power Cycles:" "$power_cycles"
                
                if [[ "$HEALTH_VERBOSE" == true ]]; then
                    echo
                    echo "  Health Assessment:"
                    case "$health_status" in
                        "good")
                            echo "  • Drive is operating normally"
                            echo "  • All SMART parameters within acceptable ranges"
                            ;;
                        "warning")
                            echo "  • Drive shows warning indicators"
                            echo "  • Monitor closely and consider replacement"
                            ;;
                        "critical")
                            echo "  • Drive failure imminent or detected"
                            echo "  • Immediate replacement recommended"
                            ;;
                    esac
                fi
            fi
        else
            if [[ "$HEALTH_QUIET" == true ]]; then
                echo "Position $position: error ($health_info)"
            else
                printf "  %-20s %s\n" "Position:" "$position"
                printf "  %-20s %s\n" "Status:" "⚠️  $health_info"
            fi
        fi
        
        if [[ "$HEALTH_QUIET" == false ]]; then
            echo
        fi
    fi
}

#-------------------------------------------------------------------------------
# Main health command function
#-------------------------------------------------------------------------------
function health {
    # Parse arguments
    if ! this::parse_args "$@"; then
        local parse_exit_code=$?
        if [[ $parse_exit_code -eq 255 ]]; then
            # Help was shown, exit successfully
            exit 0
        else
            # Error in arguments
            exit 1
        fi
    fi
    
    local target="$HEALTH_TARGET"
    local controller="${POOLTOOL_CONTROLLER:-1}"
    local exit_code=0
    local critical_found=false
    
    # Get unified device data
    local unified_data
    unified_data=$(pooltool::create_unified_mapping "$controller" 2>/dev/null)
    if [[ -z "$unified_data" ]]; then
        if [[ "$HEALTH_JSON" == true ]]; then
            echo '{"error": "Unable to retrieve system data", "accessible": false}'
        else
            echo "Error: Unable to retrieve system data" >&2
        fi
        exit 5
    fi
    
    mapfile -t unified_array <<< "$unified_data"
    
    if [[ "$target" == "all" ]]; then
        # Check all drives efficiently using bulk health collection
        local health_results
        if ! health_results=$(pooltool::get_all_health_info_efficient "$controller" "${unified_array[@]}" 2>/dev/null); then
            if [[ "$HEALTH_JSON" == true ]]; then
                echo '{"error": "Unable to retrieve health data", "accessible": false}'
            else
                echo "Error: Unable to retrieve health data for drives" >&2
            fi
            exit 5
        fi
        
        local results=()
        local positions=()
        
        # Parse the bulk health results and convert to our format
        while IFS= read -r line; do
            if [[ "$line" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
                local mount_name="${BASH_REMATCH[1]}"
                local snapraid_name="${BASH_REMATCH[2]}"
                local rec_connector="${BASH_REMATCH[3]}"
                local rec_device="${BASH_REMATCH[4]}"
                local mount_path="${BASH_REMATCH[5]}"
                local system_device="${BASH_REMATCH[6]}"
                local health_status="${BASH_REMATCH[14]}"
                local temperature="${BASH_REMATCH[15]}"
                local power_hours="${BASH_REMATCH[16]}"
                local reallocated_sectors="${BASH_REMATCH[17]}"
                
                # Calculate position using the same logic as select command
                local calc_position=$(( rec_connector * 4 + (4 - rec_device) ))
                positions+=("$calc_position")
                
                # Format health data like get_drive_health_data output
                local health_data="$health_status:$temperature:$power_hours:$reallocated_sectors"
                local result="found:$calc_position:$system_device:$mount_name:$mount_path:$health_data"
                results+=("$result")
                
                # Check for critical status
                if [[ "$health_status" == "critical" ]]; then
                    critical_found=true
                fi
                
                # Track exit codes - warning and critical should return appropriate codes
                case "$health_status" in
                    "critical") exit_code=3 ;;
                    "warning") [[ $exit_code -lt 1 ]] && exit_code=1 ;;
                esac
            fi
        done <<< "$health_results"
        
        # Sort results by position for consistent output
        local sorted_results=()
        IFS=$'\n' sorted_positions=($(printf '%s\n' "${positions[@]}" | sort -n))
        unset IFS
        
        for pos in "${sorted_positions[@]}"; do
            for result in "${results[@]}"; do
                if [[ "$result" =~ ^found:$pos: ]]; then
                    sorted_results+=("$result")
                    break
                fi
            done
        done
        results=("${sorted_results[@]}")
        
        # Output results
        if [[ "$HEALTH_JSON" == true ]]; then
            echo "{"
            echo "  \"drives\": ["
            for i in "${!results[@]}"; do
                echo -n "    "
                this::output_json_single "${results[$i]}"
                if [[ $i -lt $((${#results[@]} - 1)) ]]; then
                    echo ","
                else
                    echo
                fi
            done
            echo "  ],"
            echo "  \"summary\": {"
            echo "    \"total_drives\": ${#results[@]},"
            echo "    \"critical_found\": $critical_found"
            echo "  }"
            echo "}"
        else
            if [[ "$HEALTH_QUIET" == false ]]; then
                echo "🏥 SYSTEM HEALTH CHECK"
                echo "════════════════════"
                echo
            fi
            
            for result in "${results[@]}"; do
                this::output_standard_single "$result"
            done
            
            if [[ "$HEALTH_QUIET" == false ]]; then
                echo "Health check complete for ${#results[@]} drives."
                if [[ "$critical_found" == true ]]; then
                    echo "⚠️  Critical drives detected - immediate attention required!"
                fi
            fi
        fi
        
    else
        # Check single drive
        local result
        result=$(this::get_drive_health_data "$target" "$controller" "${unified_array[@]}")
        exit_code=$?
        
        if [[ "$HEALTH_JSON" == true ]]; then
            this::output_json_single "$result"
        else
            this::output_standard_single "$result"
        fi
        
        # Check for critical status
        if [[ "$result" =~ :critical: ]]; then
            exit_code=3
        fi
    fi
    
    exit $exit_code
}
