#!/bin/bash

# Pooltool Workflow Engine - Core workflow management system
# Part of Phase 3.2: Advanced Workflows
# Created: September 4, 2025

NAMESPACE="global"

# Workflow state management
declare -g WORKFLOW_STATE_DIR="/tmp/pooltool-workflows"
declare -g WORKFLOW_LOG_DIR="/var/log/pooltool"
declare -g WORKFLOW_CURRENT_ID=""
declare -g WORKFLOW_CURRENT_STEP=""
declare -g WORKFLOW_TOTAL_STEPS=0

# Workflow step status codes
declare -gr WORKFLOW_STEP_PENDING=0
declare -gr WORKFLOW_STEP_RUNNING=1
declare -gr WORKFLOW_STEP_COMPLETE=2
declare -gr WORKFLOW_STEP_FAILED=3
declare -gr WORKFLOW_STEP_SKIPPED=4

# Sudo session management
declare -g WORKFLOW_SUDO_INITIALIZED=false
declare -g WORKFLOW_SUDO_TIMESTAMP=""

#
# Initialize workflow system
#
workflow_engine_init() {
    # Create state directory if it doesn't exist
    if [[ ! -d "$WORKFLOW_STATE_DIR" ]]; then
        mkdir -p "$WORKFLOW_STATE_DIR" || {
            echo "Error: Cannot create workflow state directory: $WORKFLOW_STATE_DIR" >&2
            return 1
        }
    fi
    
    # Create log directory if it doesn't exist
    if [[ ! -d "$WORKFLOW_LOG_DIR" ]]; then
        # Try to create system log directory with proper permissions
        if sudo mkdir -p "$WORKFLOW_LOG_DIR" 2>/dev/null && sudo chmod 755 "$WORKFLOW_LOG_DIR" 2>/dev/null; then
            # Make it writable by current user
            if ! sudo chown "$USER:$USER" "$WORKFLOW_LOG_DIR" 2>/dev/null; then
                # If we can't make it user-writable, fallback immediately
                WORKFLOW_LOG_DIR="$HOME/.pooltool/logs"
                mkdir -p "$WORKFLOW_LOG_DIR" || {
                    echo "Warning: Cannot create log directory, logging disabled" >&2
                    WORKFLOW_LOG_DIR=""
                }
            fi
        else
            # Fallback to user directory if no sudo access or creation fails
            WORKFLOW_LOG_DIR="$HOME/.pooltool/logs"
            mkdir -p "$WORKFLOW_LOG_DIR" || {
                echo "Warning: Cannot create log directory, logging disabled" >&2
                WORKFLOW_LOG_DIR=""
            }
        fi
    fi
    
    # Test write permissions to log directory
    if [[ -n "$WORKFLOW_LOG_DIR" && -d "$WORKFLOW_LOG_DIR" ]]; then
        if ! touch "$WORKFLOW_LOG_DIR/test.tmp" 2>/dev/null; then
            echo "Warning: Log directory not writable, using fallback: $HOME/.pooltool/logs" >&2
            WORKFLOW_LOG_DIR="$HOME/.pooltool/logs"
            mkdir -p "$WORKFLOW_LOG_DIR" || {
                echo "Warning: Cannot create log directory, logging disabled" >&2
                WORKFLOW_LOG_DIR=""
            }
        else
            rm -f "$WORKFLOW_LOG_DIR/test.tmp" 2>/dev/null
        fi
    fi
    
    return 0
}

#
# Start a new workflow
# $1: workflow_name (e.g., "drive_replacement")
# $2: total_steps (number of steps in workflow)
# $3: optional: require_sudo (true|false, default: true)
# Returns: workflow_id
#
workflow_start() {
    local workflow_name="$1"
    local total_steps="$2"
    local require_sudo="${3:-true}"
    
    if [[ -z "$workflow_name" || -z "$total_steps" ]]; then
        echo "Error: workflow_start requires workflow_name and total_steps" >&2
        return 1
    fi
    
    # Initialize sudo session if required
    if [[ "$require_sudo" == true ]]; then
        if ! workflow_sudo_init; then
            echo "Error: Failed to initialize sudo session for workflow" >&2
            return 1
        fi
    fi
    
    # Generate unique workflow ID
    local workflow_id="${workflow_name}_$(date +%Y%m%d_%H%M%S)_$$"
    
    # Initialize workflow state
    WORKFLOW_CURRENT_ID="$workflow_id"
    WORKFLOW_CURRENT_STEP=0
    WORKFLOW_TOTAL_STEPS="$total_steps"
    
    # Create workflow state file
    local state_file="$WORKFLOW_STATE_DIR/${workflow_id}.state"
    {
        echo "workflow_name=$workflow_name"
        echo "workflow_id=$workflow_id"
        echo "total_steps=$total_steps"
        echo "current_step=0"
        echo "status=running"
        echo "started=$(date -Iseconds)"
        echo "require_sudo=$require_sudo"
    } > "$state_file"
    
    # Log workflow start
    workflow_log "INFO" "Started workflow: $workflow_name (ID: $workflow_id, Steps: $total_steps)"
    
    echo "$workflow_id"
    return 0
}

#
# Update workflow step
# $1: step_number
# $2: step_name
# $3: step_status (pending|running|complete|failed|skipped)
# $4: optional message
#
workflow_step() {
    local step_number="$1"
    local step_name="$2"
    local step_status="$3"
    local message="$4"
    
    if [[ -z "$WORKFLOW_CURRENT_ID" ]]; then
        echo "Error: No active workflow" >&2
        return 1
    fi
    
    local state_file="$WORKFLOW_STATE_DIR/${WORKFLOW_CURRENT_ID}.state"
    
    # Update current step
    WORKFLOW_CURRENT_STEP="$step_number"
    
    # Update state file
    sed -i "s/current_step=.*/current_step=$step_number/" "$state_file"
    echo "step_${step_number}_name=\"$step_name\"" >> "$state_file"
    echo "step_${step_number}_status=\"$step_status\"" >> "$state_file"
    echo "step_${step_number}_timestamp=\"$(date -Iseconds)\"" >> "$state_file"
    
    if [[ -n "$message" ]]; then
        echo "step_${step_number}_message=\"$message\"" >> "$state_file"
    fi
    
    # Log step update
    local log_level="INFO"
    case "$step_status" in
        "failed") log_level="ERROR" ;;
        "running") log_level="INFO" ;;
        "complete") log_level="INFO" ;;
    esac
    
    workflow_log "$log_level" "Step $step_number/$WORKFLOW_TOTAL_STEPS: $step_name - $step_status"
    if [[ -n "$message" ]]; then
        workflow_log "$log_level" "  Message: $message"
    fi
    
    # Show progress indicators for step status changes
    case "$step_status" in
        "running")
            echo "🔄 Starting: $step_name (Step $step_number/$WORKFLOW_TOTAL_STEPS)" >&2
            ;;
        "complete")
            echo "✅ Completed: $step_name (Step $step_number/$WORKFLOW_TOTAL_STEPS)" >&2
            # Show progress bar after each completed step (only if total steps > 0)
            if [[ "$WORKFLOW_TOTAL_STEPS" -gt 0 ]]; then
                local progress_percent=$((step_number * 100 / WORKFLOW_TOTAL_STEPS))
                echo "   Progress: $progress_percent% [$(printf '%*s' $((step_number * 20 / WORKFLOW_TOTAL_STEPS)) '' | tr ' ' '▓')$(printf '%*s' $((20 - step_number * 20 / WORKFLOW_TOTAL_STEPS)) '' | tr ' ' '░')]" >&2
            else
                echo "   Progress: Unable to calculate (total steps not set)" >&2
            fi
            ;;
        "failed")
            echo "❌ Failed: $step_name (Step $step_number/$WORKFLOW_TOTAL_STEPS)" >&2
            [[ -n "$message" ]] && echo "   Error: $message" >&2
            ;;
        "skipped")
            echo "⏭️ Skipped: $step_name (Step $step_number/$WORKFLOW_TOTAL_STEPS)" >&2
            ;;
    esac
    
    return 0
}

#
# Complete workflow
# $1: status (success|failed|aborted)
# $2: optional message
#
workflow_complete() {
    local status="$1"
    local message="$2"
    
    if [[ -z "$WORKFLOW_CURRENT_ID" ]]; then
        echo "Error: No active workflow" >&2
        return 1
    fi
    
    local state_file="$WORKFLOW_STATE_DIR/${WORKFLOW_CURRENT_ID}.state"
    
    # Update state file
    sed -i "s/status=.*/status=$status/" "$state_file"
    echo "completed=\"$(date -Iseconds)\"" >> "$state_file"
    
    if [[ -n "$message" ]]; then
        echo "completion_message=\"$message\"" >> "$state_file"
    fi
    
    # Log completion
    local log_level="INFO"
    [[ "$status" == "failed" ]] && log_level="ERROR"
    
    workflow_log "$log_level" "Workflow completed: $status"
    if [[ -n "$message" ]]; then
        workflow_log "$log_level" "  Message: $message"
    fi
    
    # Clean up active workflow state
    WORKFLOW_CURRENT_ID=""
    WORKFLOW_CURRENT_STEP=""
    WORKFLOW_TOTAL_STEPS=0
    
    # Clean up sudo session
    workflow_sudo_cleanup
    
    return 0
}

#
# Display workflow progress with visual indicators
#
workflow_progress() {
    if [[ -z "$WORKFLOW_CURRENT_ID" ]]; then
        echo "No active workflow"
        return 1
    fi
    
    echo "Workflow Progress: Step $WORKFLOW_CURRENT_STEP/$WORKFLOW_TOTAL_STEPS"
    
    # Create progress bar (only if total steps > 0)
    if [[ "$WORKFLOW_TOTAL_STEPS" -gt 0 ]]; then
        local progress_width=40
        local completed_steps=$((WORKFLOW_CURRENT_STEP * progress_width / WORKFLOW_TOTAL_STEPS))
        local remaining_steps=$((progress_width - completed_steps))
        
        printf "["
        printf "%*s" "$completed_steps" "" | tr ' ' '▓'
        printf "%*s" "$remaining_steps" "" | tr ' ' '░'
        printf "] %d%%\n" $((WORKFLOW_CURRENT_STEP * 100 / WORKFLOW_TOTAL_STEPS))
    else
        echo "Progress: Unable to calculate (total steps not set)"
    fi
    
    return 0
}

#
# Display enhanced workflow progress with step details
#
workflow_progress_detailed() {
    if [[ -z "$WORKFLOW_CURRENT_ID" ]]; then
        echo "No active workflow"
        return 1
    fi
    
    local state_file="$WORKFLOW_STATE_DIR/${WORKFLOW_CURRENT_ID}.state"
    if [[ ! -f "$state_file" ]]; then
        echo "Workflow state file not found"
        return 1
    fi
    
    # Source state file to get workflow info
    local workflow_name workflow_id total_steps current_step status started
    source "$state_file"
    
    echo "📊 WORKFLOW PROGRESS"
    echo "═══════════════════════════════════════════════════════════════════"
    printf "%-15s %s\n" "Workflow:" "$workflow_name"
    printf "%-15s %s\n" "ID:" "$workflow_id"
    printf "%-15s %s\n" "Status:" "$status"
    printf "%-15s %d/%d steps\n" "Progress:" "$current_step" "$total_steps"
    printf "%-15s %s\n" "Started:" "$started"
    
    echo ""
    echo "Progress Bar:"
    workflow_progress
    
    echo ""
    echo "📋 Step Details:"
    echo "─────────────────────────────────────────────────────────────────────"
    
    # Show step details from state file
    for ((i=1; i<=total_steps; i++)); do
        local step_name=$(grep "step_${i}_name=" "$state_file" | cut -d'=' -f2-)
        local step_status=$(grep "step_${i}_status=" "$state_file" | cut -d'=' -f2-)
        local step_timestamp=$(grep "step_${i}_timestamp=" "$state_file" | cut -d'=' -f2-)
        
        if [[ -n "$step_name" ]]; then
            local status_icon="⏳"
            case "$step_status" in
                "complete") status_icon="✅" ;;
                "running") status_icon="🔄" ;;
                "failed") status_icon="❌" ;;
                "skipped") status_icon="⏭️" ;;
                *) status_icon="⏳" ;;
            esac
            
            printf "%s Step %d: %s" "$status_icon" "$i" "$step_name"
            if [[ -n "$step_timestamp" ]]; then
                local time_short=$(echo "$step_timestamp" | cut -d'T' -f2 | cut -d'+' -f1)
                printf " (%s)" "$time_short"
            fi
            echo ""
        else
            printf "⏳ Step %d: (pending)\n" "$i"
        fi
    done
    
    return 0
}

#
# Log workflow messages
# $1: level (INFO|WARN|ERROR|DEBUG)
# $2: message
#
workflow_log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -Iseconds)
    
    # Log to console with color coding (all to stderr to avoid interfering with command substitution)
    case "$level" in
        "ERROR") echo -e "\033[31m[$timestamp] $level: $message\033[0m" >&2 ;;
        "WARN")  echo -e "\033[33m[$timestamp] $level: $message\033[0m" >&2 ;;
        "INFO")  echo -e "\033[32m[$timestamp] $level: $message\033[0m" >&2 ;;
        "DEBUG") echo -e "\033[36m[$timestamp] $level: $message\033[0m" >&2 ;;
        *)       echo "[$timestamp] $level: $message" >&2 ;;
    esac
    
    # Log to file if directory available
    if [[ -n "$WORKFLOW_LOG_DIR" && -d "$WORKFLOW_LOG_DIR" ]]; then
        local log_file="$WORKFLOW_LOG_DIR/workflow.log"
        echo "[$timestamp] $level: $message" >> "$log_file"
    fi
    
    return 0
}

#
# Get workflow status
# $1: optional workflow_id (defaults to current)
#
workflow_status() {
    local workflow_id="${1:-$WORKFLOW_CURRENT_ID}"
    
    if [[ -z "$workflow_id" ]]; then
        echo "Error: No workflow ID specified and no active workflow" >&2
        return 1
    fi
    
    local state_file="$WORKFLOW_STATE_DIR/${workflow_id}.state"
    
    if [[ ! -f "$state_file" ]]; then
        echo "Error: Workflow state file not found: $state_file" >&2
        return 1
    fi
    
    # Source state file and display status
    (
        source "$state_file"
        echo "Workflow: $workflow_name"
        echo "ID: $workflow_id"
        echo "Status: $status"
        echo "Progress: $current_step/$total_steps steps"
        echo "Started: $started"
        [[ -n "$completed" ]] && echo "Completed: $completed"
    )
    
    return 0
}

#
# List all workflows
#
workflow_list() {
    if [[ ! -d "$WORKFLOW_STATE_DIR" ]]; then
        echo "No workflows found"
        return 0
    fi
    
    local state_files=("$WORKFLOW_STATE_DIR"/*.state)
    
    if [[ ! -f "${state_files[0]}" ]]; then
        echo "No workflows found"
        return 0
    fi
    
    printf "%-30s %-20s %-10s %-15s\n" "WORKFLOW ID" "NAME" "STATUS" "PROGRESS"
    printf "%-30s %-20s %-10s %-15s\n" "$(printf '%*s' 30 '' | tr ' ' '-')" "$(printf '%*s' 20 '' | tr ' ' '-')" "$(printf '%*s' 10 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')"
    
    for state_file in "${state_files[@]}"; do
        (
            source "$state_file"
            printf "%-30s %-20s %-10s %-15s\n" "$workflow_id" "$workflow_name" "$status" "$current_step/$total_steps"
        )
    done
    
    return 0
}

#
# Clean up old workflows
# $1: days_old (default: 30)
#
workflow_cleanup() {
    local days_old="${1:-30}"
    
    if [[ ! -d "$WORKFLOW_STATE_DIR" ]]; then
        return 0
    fi
    
    # Find and remove old state files
    find "$WORKFLOW_STATE_DIR" -name "*.state" -mtime +$days_old -delete 2>/dev/null
    
    # Clean up old log files
    if [[ -n "$WORKFLOW_LOG_DIR" && -d "$WORKFLOW_LOG_DIR" ]]; then
        find "$WORKFLOW_LOG_DIR" -name "*.log" -mtime +$days_old -delete 2>/dev/null
    fi
    
    workflow_log "INFO" "Cleaned up workflows older than $days_old days"
    return 0
}

# Initialize workflow engine when module is loaded
workflow_engine_init

#
# Sudo session management functions
#

#
# Initialize sudo session for workflow operations
# Should be called at the start of any workflow requiring sudo
#
workflow_sudo_init() {
    workflow_log "INFO" "Initializing sudo session for workflow operations"
    
    # Check if sudo is already available
    if sudo -n true 2>/dev/null; then
        workflow_log "INFO" "Sudo session already active"
        WORKFLOW_SUDO_INITIALIZED=true
        WORKFLOW_SUDO_TIMESTAMP=$(date +%s)
        return 0
    fi
    
    # Prompt for sudo password upfront
    echo "🔐 Administrative privileges required for drive operations" >&2
    echo "Please enter your password to initialize secure session..." >&2
    
    if sudo -v; then
        WORKFLOW_SUDO_INITIALIZED=true
        WORKFLOW_SUDO_TIMESTAMP=$(date +%s)
        workflow_log "INFO" "Sudo session initialized successfully"
        
        # Set up automatic sudo refresh during long operations
        workflow_sudo_refresh_background &
        
        return 0
    else
        workflow_log "ERROR" "Failed to initialize sudo session"
        echo "❌ Failed to initialize administrative session" >&2
        echo "   Drive operations require administrative privileges" >&2
        return 1
    fi
}

#
# Refresh sudo session to prevent timeout during long workflows
#
workflow_sudo_refresh() {
    if [[ "$WORKFLOW_SUDO_INITIALIZED" == true ]]; then
        if sudo -v 2>/dev/null; then
            WORKFLOW_SUDO_TIMESTAMP=$(date +%s)
            workflow_log "DEBUG" "Sudo session refreshed"
            return 0
        else
            workflow_log "WARN" "Sudo session refresh failed"
            WORKFLOW_SUDO_INITIALIZED=false
            return 1
        fi
    fi
    return 1
}

#
# Background sudo refresh to maintain session during long operations
#
workflow_sudo_refresh_background() {
    # Run in background to refresh sudo every 4 minutes (sudo timeout is usually 5 minutes)
    while [[ "$WORKFLOW_SUDO_INITIALIZED" == true ]]; do
        sleep 240  # 4 minutes
        if [[ "$WORKFLOW_SUDO_INITIALIZED" == true ]]; then
            workflow_sudo_refresh
        fi
    done
}

#
# Check if sudo session is valid
#
workflow_sudo_check() {
    if [[ "$WORKFLOW_SUDO_INITIALIZED" != true ]]; then
        workflow_log "ERROR" "Sudo session not initialized"
        echo "❌ Administrative session not initialized" >&2
        echo "   Call workflow_sudo_init first" >&2
        return 1
    fi
    
    # Check if session is still valid
    if sudo -n true 2>/dev/null; then
        return 0
    else
        workflow_log "WARN" "Sudo session has expired"
        WORKFLOW_SUDO_INITIALIZED=false
        echo "⚠️  Administrative session has expired" >&2
        echo "   Please run workflow_sudo_init to refresh" >&2
        return 1
    fi
}

#
# Execute command with sudo, with session validation
#
workflow_sudo_exec() {
    local command="$@"
    
    if ! workflow_sudo_check; then
        return 1
    fi
    
    workflow_log "DEBUG" "Executing sudo command: $command"
    sudo "$@"
}

#
# Clean up sudo session
#
workflow_sudo_cleanup() {
    if [[ "$WORKFLOW_SUDO_INITIALIZED" == true ]]; then
        workflow_log "INFO" "Cleaning up sudo session"
        WORKFLOW_SUDO_INITIALIZED=false
        WORKFLOW_SUDO_TIMESTAMP=""
        
        # Kill background refresh process if running
        pkill -f "workflow_sudo_refresh_background" 2>/dev/null || true
    fi
}

#
# Error handling and recovery functions
#

#
# Handle workflow errors with recovery suggestions
# $1: error_type (auth|permission|hardware|network|user|unknown)
# $2: error_message
# $3: optional recovery_suggestion
#
workflow_handle_error() {
    local error_type="$1"
    local error_message="$2"
    local recovery_suggestion="$3"
    
    workflow_log "ERROR" "Workflow error ($error_type): $error_message"
    
    echo "❌ WORKFLOW ERROR" >&2
    echo "═══════════════════════════════════════════════════════════════════" >&2
    echo "Error Type: $error_type" >&2
    echo "Message: $error_message" >&2
    
    # Provide specific recovery suggestions based on error type
    case "$error_type" in
        "auth")
            echo "" >&2
            echo "🔐 AUTHENTICATION ERROR" >&2
            echo "This operation requires administrative privileges." >&2
            echo "" >&2
            echo "💡 Recovery Options:" >&2
            echo "1. Run: sudo -v  (refresh sudo session)" >&2
            echo "2. Check if your user has sudo privileges" >&2
            echo "3. Contact system administrator if needed" >&2
            ;;
        "permission")
            echo "" >&2
            echo "🚫 PERMISSION ERROR" >&2
            echo "Insufficient permissions to access required resources." >&2
            echo "" >&2
            echo "💡 Recovery Options:" >&2
            echo "1. Check file/directory permissions" >&2
            echo "2. Ensure sudo access is working: sudo -v" >&2
            echo "3. Verify disk is not read-only: mount | grep ro" >&2
            ;;
        "hardware")
            echo "" >&2
            echo "🔧 HARDWARE ERROR" >&2
            echo "Hardware component is not responding or accessible." >&2
            echo "" >&2
            echo "💡 Recovery Options:" >&2
            echo "1. Check physical connections (SATA, power)" >&2
            echo "2. Verify drive is properly seated in bay" >&2
            echo "3. Try different SATA port if available" >&2
            echo "4. Check system logs: dmesg | grep -i error" >&2
            ;;
        "network")
            echo "" >&2
            echo "🌐 NETWORK ERROR" >&2
            echo "Network connectivity or remote resource issue." >&2
            echo "" >&2
            echo "💡 Recovery Options:" >&2
            echo "1. Check network connectivity: ping 8.8.8.8" >&2
            echo "2. Verify DNS resolution: nslookup domain.com" >&2
            echo "3. Check firewall settings if applicable" >&2
            ;;
        "user")
            echo "" >&2
            echo "👤 USER INPUT ERROR" >&2
            echo "Invalid input or user cancelled operation." >&2
            echo "" >&2
            echo "💡 Recovery Options:" >&2
            echo "1. Review input requirements and try again" >&2
            echo "2. Use --help flag for command documentation" >&2
            echo "3. Check examples in help output" >&2
            ;;
        *)
            echo "" >&2
            echo "❓ UNKNOWN ERROR" >&2
            echo "An unexpected error occurred." >&2
            echo "" >&2
            echo "💡 Recovery Options:" >&2
            echo "1. Check log files for detailed information" >&2
            echo "2. Try running the operation again" >&2
            echo "3. Contact support with error details" >&2
            ;;
    esac
    
    # Add custom recovery suggestion if provided
    if [[ -n "$recovery_suggestion" ]]; then
        echo "" >&2
        echo "🎯 Specific Recovery Suggestion:" >&2
        echo "$recovery_suggestion" >&2
    fi
    
    echo "" >&2
    echo "📋 Current Workflow Status:" >&2
    if [[ -n "$WORKFLOW_CURRENT_ID" ]]; then
        echo "Workflow ID: $WORKFLOW_CURRENT_ID" >&2
        echo "Current Step: $WORKFLOW_CURRENT_STEP/$WORKFLOW_TOTAL_STEPS" >&2
        echo "You can check detailed status with: pooltool workflow status $WORKFLOW_CURRENT_ID" >&2
    else
        echo "No active workflow" >&2
    fi
    
    return 1
}

#
# Graceful workflow abort with cleanup
# $1: abort_reason
#
workflow_abort() {
    local abort_reason="$1"
    
    if [[ -n "$WORKFLOW_CURRENT_ID" ]]; then
        workflow_log "WARN" "Aborting workflow: $abort_reason"
        workflow_complete "aborted" "$abort_reason"
        
        echo "🛑 WORKFLOW ABORTED" >&2
        echo "═══════════════════════════════════════════════════════════════════" >&2
        echo "Reason: $abort_reason" >&2
        echo "" >&2
        echo "✅ Cleanup completed successfully" >&2
        echo "📋 Workflow state saved for reference" >&2
    else
        echo "⚠️  No active workflow to abort" >&2
    fi
}

#
# Emergency workflow stop with immediate cleanup
#
workflow_emergency_stop() {
    echo "" >&2
    echo "🚨 EMERGENCY WORKFLOW STOP" >&2
    echo "═══════════════════════════════════════════════════════════════════" >&2
    
    # Immediate cleanup
    workflow_sudo_cleanup
    
    if [[ -n "$WORKFLOW_CURRENT_ID" ]]; then
        workflow_complete "emergency_stop" "Emergency stop requested"
        echo "✅ Emergency cleanup completed" >&2
        echo "📋 Workflow state preserved for analysis" >&2
    fi
    
    echo "" >&2
    echo "🔍 Next Steps:" >&2
    echo "1. Review what went wrong" >&2
    echo "2. Check system status before retrying" >&2
    echo "3. Consider running safety checks first" >&2
    
    exit 1
}

# Set up signal handlers for graceful error handling
trap 'workflow_emergency_stop' INT TERM
