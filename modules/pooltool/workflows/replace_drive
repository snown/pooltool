#!/bin/bash

# Pooltool Drive Replacement Wizard - Guided drive replacement workflow
# Part of Phase 3.2: Advanced Workflows
# Created: September 4, 2025

NAMESPACE="global"

# Drive replacement workflow steps
declare -gr REPLACE_STEP_ASSESSMENT=1
declare -gr REPLACE_STEP_SAFETY=2
declare -gr REPLACE_STEP_PREPARATION=3
declare -gr REPLACE_STEP_PHYSICAL=4
declare -gr REPLACE_STEP_MIGRATION=5
declare -gr REPLACE_STEP_VALIDATION=6
declare -gr REPLACE_TOTAL_STEPS=6

#
# Initialize drive replacement wizard
#
replace_drive_init() {
    # Load required modules
    bootstrap_load_module pooltool/workflows/workflow_engine
    bootstrap_load_module pooltool/workflows/safety_checks
    bootstrap_load_module pooltool/driveutils
    bootstrap_load_module pooltool/healthutils
    bootstrap_load_module pooltool/capacityutils
    bootstrap_load_module pooltool/ask_question
    bootstrap_load_module pooltool/commands/blink
    
    # Load SnapRAID integration modules from existing disk command
    bootstrap_load_module snapraid/devices
    bootstrap_load_module snown/script_sudo
    
    return 0
}

#
# Main drive replacement wizard entry point - Unified data management wizard
# Now supports: Adding drives, Upgrading drives, Replacing failed drives
#
replace_drive_wizard() {
    local target_position="$1"
    local operation_mode="$2"  # upgrade, recovery, add, or empty for interactive
    
    echo "� DRIVE MANAGEMENT WIZARD"
    echo "═══════════════════════════════════════════════════════════════════"
    echo "This wizard will guide you through drive management operations with"
    echo "comprehensive safety checks and step-by-step guidance."
    echo ""
    
    # Step 0: Determine operation type if not specified
    local operation_type=""
    if [[ -z "$operation_mode" ]]; then
        operation_type=$(replace_determine_operation_type)
        if [[ $? -ne 0 ]]; then
            echo "❌ Operation cancelled by user"
            return 1
        fi
    else
        operation_type="$operation_mode"
    fi
    
    echo "📋 Operation Selected: $operation_type"
    echo ""
    
    # Start appropriate workflow based on operation type
    case "$operation_type" in
        "upgrade")
            replace_workflow_upgrade "$target_position"
            ;;
        "recovery")
            replace_workflow_recovery "$target_position"
            ;;
        "add")
            replace_workflow_add_drive "$target_position"
            ;;
        *)
            echo "❌ Unknown operation type: $operation_type"
            return 1
            ;;
    esac
    
    return $?
}

#
# Step 0: Determine what the user wants to do
#
replace_determine_operation_type() {
    echo "🤔 What would you like to do?" >&2
    echo "═══════════════════════════════════════════════════════════════════" >&2
    echo "" >&2
    echo "Please select your goal:" >&2
    echo "" >&2
    echo "1️⃣  📈 UPGRADE A DRIVE" >&2
    echo "   • Replace a working drive with a larger or better drive" >&2
    echo "   • Both old and new drives will be connected during process" >&2
    echo "   • Direct data copy from old drive to new drive" >&2
    echo "   • Low risk - old drive remains as backup" >&2
    echo "   • Best for: capacity upgrades, newer/faster drives" >&2
    echo "" >&2
    echo "2️⃣  🚨 REPLACE A FAILED DRIVE" >&2
    echo "   • Replace a drive that has failed or is failing" >&2
    echo "   • Old drive may be inaccessible or removed" >&2
    echo "   • Data restored from SnapRAID parity" >&2
    echo "   • Medium risk - depends on parity integrity" >&2
    echo "   • Best for: drive failures, critical SMART errors" >&2
    echo "" >&2
    echo "3️⃣  ➕ ADD A NEW DRIVE" >&2
    echo "   • Add a brand new drive to expand storage" >&2
    echo "   • No data migration needed" >&2
    echo "   • Configure for SnapRAID integration" >&2
    echo "   • Low risk - no existing data involved" >&2
    echo "   • Best for: expanding array capacity" >&2
    echo "" >&2
    
    while true; do
        local choice
        choice=$(bashful input -p "Enter your choice (1-3) or 'q' to quit: " -d "")
        
        case "$choice" in
            "1")
                echo "upgrade"
                return 0
                ;;
            "2")
                echo "recovery"
                return 0
                ;;
            "3")
                echo "add"
                return 0
                ;;
            "q"|"quit")
                return 1
                ;;
            *)
                echo "❌ Invalid choice. Please enter 1, 2, 3, or 'q' to quit." >&2
                ;;
        esac
    done
}

#
# Upgrade workflow: Replace working drive with better drive
#
replace_workflow_upgrade() {
    local target_position="$1"
    
    echo "📈 DRIVE UPGRADE WORKFLOW"
    echo "═══════════════════════════════════════════════════════════════════"
    echo "This process will help you upgrade a working drive to a larger or"
    echo "better drive with direct data copy."
    echo ""
    
    # Start workflow with 7 steps for upgrade
    local workflow_id
    workflow_id=$(workflow_start "drive_upgrade" 7)
    if [[ $? -ne 0 ]]; then
        echo "❌ Failed to initialize workflow system"
        return 1
    fi
    
    # Set global workflow ID for subsequent workflow functions
    WORKFLOW_CURRENT_ID="$workflow_id"
    
    echo "📋 Upgrade Workflow ID: $workflow_id"
    echo ""
    
    # Step 1: Source Drive Assessment
    workflow_step 1 "Source Drive Assessment" "running"
    if ! replace_upgrade_step_source_assessment "$target_position"; then
        workflow_step 1 "Source Drive Assessment" "failed"
        workflow_complete "aborted" "Source drive assessment failed"
        return 1
    fi
    workflow_step 1 "Source Drive Assessment" "complete"
    
    # Step 2: New Drive Preparation
    workflow_step 2 "New Drive Preparation" "running"
    if ! replace_upgrade_step_new_drive_prep; then
        workflow_step 2 "New Drive Preparation" "failed"
        workflow_complete "aborted" "New drive preparation failed"
        return 1
    fi
    workflow_step 2 "New Drive Preparation" "complete"
    
    # Step 3: Capacity and Compatibility Check
    workflow_step 3 "Capacity and Compatibility Check" "running"
    if ! replace_upgrade_step_compatibility_check; then
        workflow_step 3 "Capacity and Compatibility Check" "failed"
        workflow_complete "aborted" "Compatibility check failed"
        return 1
    fi
    workflow_step 3 "Capacity and Compatibility Check" "complete"
    
    # Step 4: Safety Checks
    workflow_step 4 "Safety Checks" "running"
    if ! replace_step_safety "$REPLACE_TARGET_POSITION"; then
        workflow_step 4 "Safety Checks" "failed"
        workflow_complete "failed" "Safety checks failed"
        return 1
    fi
    workflow_step 4 "Safety Checks" "complete"
    
    # Step 5: Data Copy Process
    workflow_step 5 "Data Copy Process" "running"
    if ! replace_upgrade_step_data_copy; then
        workflow_step 5 "Data Copy Process" "failed"
        workflow_complete "failed" "Data copy failed"
        return 1
    fi
    workflow_step 5 "Data Copy Process" "complete"
    
    # Step 6: Drive Swap
    workflow_step 6 "Drive Swap" "running"
    if ! replace_upgrade_step_drive_swap; then
        workflow_step 6 "Drive Swap" "failed"
        workflow_complete "failed" "Drive swap failed"
        return 1
    fi
    workflow_step 6 "Drive Swap" "complete"
    
    # Step 7: Final Validation
    workflow_step 7 "Final Validation" "running"
    if ! replace_step_validation "$REPLACE_TARGET_POSITION"; then
        workflow_step 7 "Final Validation" "failed"
        workflow_complete "failed" "Validation failed"
        return 1
    fi
    workflow_step 7 "Final Validation" "complete"
    
    workflow_complete "success" "Drive upgrade completed successfully"
    
    echo ""
    echo "🎉 DRIVE UPGRADE COMPLETED SUCCESSFULLY!"
    echo "═══════════════════════════════════════════════════════════════════"
    echo "Your drive has been successfully upgraded with larger capacity!"
    
    return 0
}

#
# Recovery workflow: Replace failed drive using SnapRAID parity
#
replace_workflow_recovery() {
    local target_position="$1"
    
    echo "🚨 FAILED DRIVE RECOVERY WORKFLOW"
    echo "═══════════════════════════════════════════════════════════════════"
    echo "This process will help you replace a failed drive and recover data"
    echo "from SnapRAID parity information."
    echo ""
    
    # Start workflow with 6 steps for recovery
    local workflow_id
    workflow_id=$(workflow_start "drive_recovery" 6)
    if [[ $? -ne 0 ]]; then
        echo "❌ Failed to initialize workflow system"
        return 1
    fi
    
    # Set global workflow ID for subsequent workflow functions
    WORKFLOW_CURRENT_ID="$workflow_id"
    
    echo "📋 Recovery Workflow ID: $workflow_id"
    echo ""
    
    # Step 1: Failed Drive Assessment
    workflow_step 1 "Failed Drive Assessment" "running"
    if ! replace_recovery_step_failed_assessment "$target_position"; then
        workflow_step 1 "Failed Drive Assessment" "failed"
        workflow_complete "aborted" "Failed drive assessment cancelled"
        return 1
    fi
    workflow_step 1 "Failed Drive Assessment" "complete"
    
    # Step 2: SnapRAID Parity Check
    workflow_step 2 "SnapRAID Parity Check" "running"
    if ! replace_recovery_step_parity_check; then
        workflow_step 2 "SnapRAID Parity Check" "failed"
        workflow_complete "failed" "Parity check failed - recovery not safe"
        return 1
    fi
    workflow_step 2 "SnapRAID Parity Check" "complete"
    
    # Continue with standard steps...
    # Implementation continues with recovery-specific steps
    
    echo "🚨 RECOVERY WORKFLOW IN DEVELOPMENT"
    echo "This workflow will be fully implemented in the next iteration."
    echo "For now, please use manual SnapRAID recovery procedures."
    
    return 0
}

#
# Add drive workflow: Add new drive to array
#
replace_workflow_add_drive() {
    local target_position="$1"
    
    echo "➕ ADD NEW DRIVE WORKFLOW"
    echo "═══════════════════════════════════════════════════════════════════"
    echo "This process will help you add a brand new drive to your storage array."
    echo ""
    
    # This workflow can leverage much of the existing disk command logic
    echo "💡 NEW DRIVE ADDITION IN DEVELOPMENT"
    echo "This workflow will integrate with the existing 'disk' command functionality."
    echo "For now, you can use: pooltool disk"
    
    return 0
}

#
# Step 1: Drive Assessment - Select and analyze target drive using SnapRAID integration
# $1: optional drive position
#
replace_step_assessment() {
    local target_position="$1"
    
    echo "🔍 Step 1: Drive Assessment"
    echo "─────────────────────────────────────────────────────────────────────"
    
    # Get SnapRAID drive information
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_partitions=( $(snapraid::devices partitions) )
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    
    # Show current drive layout
    echo "Current Drive Layout:"
    
    # Use a simpler, non-blocking drive overview for the wizard
    echo "📋 Quick Drive Overview:"
    echo "   Checking SnapRAID configuration..."
    
    # Get SnapRAID drive count without expensive operations
    local snapraid_names=( $(snapraid::devices names 2>/dev/null || echo) )
    local drive_count=${#snapraid_names[@]}
    
    if [[ $drive_count -gt 0 ]]; then
        echo "   ✅ SnapRAID array detected with $drive_count drives"
        echo "   📍 For detailed drive layout, run: pooltool drivemap"
    else
        echo "   ⚠️  No SnapRAID configuration detected"
    fi
    
    echo ""
    echo "SnapRAID Array Drives:"
    echo "─────────────────────────"
    
    # Show detailed SnapRAID drive information
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        local drive_name="${snapraid_names[i]}"
        local partition="${snapraid_partitions[i]}"
        local mountpoint="${snapraid_mountpoints[i]}"
        
        # Get capacity info
        local capacity_info=""
        if [[ -n "$partition" ]]; then
            capacity_info=$(df -h "$partition" 2>/dev/null | tail -1 | awk '{print $3"/"$2" ("$5" used)"}')
        fi
        
        printf "%-8s %-15s %-25s %s\n" "$drive_name" "$partition" "$mountpoint" "$capacity_info"
    done
    
    echo ""
    
    # Get target drive selection if not provided
    if [[ -z "$target_position" ]]; then
        echo "📋 Drive Selection Options:"
        echo "1. Select by position number (1-24) from drive map above"
        echo "2. Select from SnapRAID drive list"
        echo ""
        
        local selection_method
        selection_method=$(bashful input -p "Choose selection method (1 or 2): " -d "1")
        
        case "$selection_method" in
            "1")
                # Position-based selection (existing logic)
                while true; do
                    local user_input
                    user_input=$(bashful input -p "Enter the position number (1-24) of the drive to replace: " -d "")
                    
                    if [[ "$user_input" == "q" || "$user_input" == "quit" ]]; then
                        echo "❌ Drive replacement cancelled by user"
                        return 1
                    elif [[ "$user_input" =~ ^[0-9]+$ ]] && [[ $user_input -ge 1 ]] && [[ $user_input -le 24 ]]; then
                        target_position="$user_input"
                        break
                    else
                        echo "❌ Invalid position. Please enter a number between 1 and 24, or 'q' to quit."
                    fi
                done
                ;;
            "2")
                # SnapRAID drive selection (enhanced from disk command)
                local chosen_drive
                chosen_drive=$(replace_choose_snapraid_drive)
                if [[ $? -ne 0 ]]; then
                    echo "❌ Drive selection cancelled"
                    return 1
                fi
                
                # Convert SnapRAID drive name to position
                target_position=$(replace_snapraid_name_to_position "$chosen_drive")
                if [[ -z "$target_position" ]]; then
                    echo "❌ Could not determine position for drive $chosen_drive"
                    return 1
                fi
                ;;
            "q"|"quit")
                echo "❌ Drive replacement cancelled by user"
                return 1
                ;;
            *)
                echo "❌ Invalid selection method"
                return 1
                ;;
        esac
    fi
    
    # Validate drive exists at position (existing validation logic)
    local drive_info
    if ! drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "❌ No drive found at position $target_position"
        return 1
    fi
    
    # Parse drive information
    local drive_name device_path model
    read -r drive_name device_path model <<< "$drive_info"
    
    echo "📊 Drive Analysis for Position $target_position:"
    echo "══════════════════════════════════════════════════════════════"
    
    # Show detailed drive information
    replace_show_drive_details "$target_position" "$drive_name" "$device_path" "$model"
    
    # Show SnapRAID integration details
    replace_show_snapraid_integration "$drive_name"
    
    echo ""
    echo "⚠️  IMPORTANT CONSIDERATIONS:"
    echo "• Replacing this drive will require data migration or rebuild"
    echo "• Ensure you have recent backups before proceeding"
    echo "• The process may take several hours depending on data size"
    echo "• System will remain operational during most of the process"
    
    echo ""
    if ! pooltool::question -p "Do you want to proceed with replacing drive at position $target_position?" -d "n"; then
        echo "❌ Drive replacement cancelled by user"
        return 1
    fi
    
    # Store target information globally for other steps
    REPLACE_TARGET_POSITION="$target_position"
    REPLACE_TARGET_DRIVE="$drive_name"
    REPLACE_TARGET_DEVICE="$device_path"
    REPLACE_TARGET_MODEL="$model"
    
    echo "✅ Drive assessment completed - Position $target_position confirmed"
    return 0
}

#
# Enhanced SnapRAID drive selection (based on disk command logic)
#
replace_choose_snapraid_drive() {
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_partitions=( $(snapraid::devices partitions) )
    local show_detail=false
    
    while true; do
        local chosen=""
        
        if [[ "$show_detail" == false ]]; then
            chosen="$(bashful choice -p "Which drive would you like to replace?" "${snapraid_names[@]}" "More info..." "Cancel")"
        else
            local detailed_choices=()
            for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
                local choice="${snapraid_names[i]}"
                if [[ -n "${snapraid_partitions[i]}" ]]; then
                    choice+="$(df -H --output="avail,size" "${snapraid_partitions[i]}" 2>/dev/null | tail -n 1 | awk '{ print " ("$1,"available of",$2")" }')"
                fi
                detailed_choices+=( "$choice" )
            done
            chosen="$(bashful choice -p "Which drive would you like to replace?" "${detailed_choices[@]}" "Cancel")"
        fi
        
        if [[ "$chosen" == "More info..." ]]; then
            show_detail=true
            continue
        elif [[ "$chosen" == "Cancel" ]]; then
            return 1
        fi
        
        # Extract drive name (remove capacity info if present)
        chosen="${chosen%% *}"
        echo "$chosen"
        return 0
    done
}

#
# Convert SnapRAID drive name to position number
#
replace_snapraid_name_to_position() {
    local snapraid_drive="$1"
    
    # This would need to be implemented based on the mapping between
    # SnapRAID drive names and physical positions
    # For now, return empty to indicate we need the position-based method
    echo ""
}

#
# Show SnapRAID integration details for a drive
#
replace_show_snapraid_integration() {
    local drive_name="$1"
    
    echo ""
    echo "🗄️  SnapRAID Integration:"
    
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_partitions=( $(snapraid::devices partitions) )
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    
    # Find drive in SnapRAID arrays
    local found=false
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$drive_name" ]]; then
            echo "   Role: ${snapraid_names[i]}"
            echo "   Partition: ${snapraid_partitions[i]}"
            echo "   Mount Point: ${snapraid_mountpoints[i]}"
            
            # Check if it's a parity drive
            if [[ "$drive_name" =~ PPU[0-9]+ ]]; then
                echo "   ⚠️  WARNING: This is a PARITY drive - replacement requires special care"
            else
                echo "   Type: Data drive"
            fi
            
            found=true
            break
        fi
    done
    
    if [[ "$found" == false ]]; then
        echo "   ⚠️  Drive not found in current SnapRAID configuration"
        echo "   💡 This may be a new drive or not yet configured"
    fi
}

#
# Step 2: Safety Checks - Run comprehensive safety validation
# $1: target position
#
replace_step_safety() {
    local target_position="$1"
    
    echo ""
    echo "🛡️  Step 2: Safety Checks"
    echo "─────────────────────────────────────────────────────────────────────"
    
    # Run pre-flight safety checks
    if ! safety_preflight_check "replace_drive" "$target_position"; then
        local safety_result=$?
        
        echo ""
        case $safety_result in
            $SAFETY_CHECK_WARN)
                echo "⚠️  Safety warnings detected. Review the issues above."
                if ! pooltool::question -p "Do you want to continue despite warnings?" -d "n"; then
                    echo "❌ Drive replacement cancelled due to safety concerns"
                    return 1
                fi
                ;;
            $SAFETY_CHECK_FAIL)
                echo "❌ Safety checks failed. Please resolve the issues before proceeding."
                if ! pooltool::question -p "Force continue anyway? (NOT RECOMMENDED)" -d "n"; then
                    echo "❌ Drive replacement cancelled due to safety failures"
                    return 1
                fi
                ;;
            $SAFETY_CHECK_CRITICAL)
                echo "🚨 Critical safety issues detected. Operation cannot proceed safely."
                echo "❌ Drive replacement cancelled due to critical safety issues"
                return 1
                ;;
        esac
    fi
    
    echo ""
    # Safety confirmation with risk assessment
    local risk_details="Drive: $REPLACE_TARGET_DRIVE at position $target_position
Model: $REPLACE_TARGET_MODEL
This operation will involve:
• Physical drive removal and installation
• Data migration or parity rebuild
• Temporary system exposure during replacement"
    
    if ! safety_confirm_operation "Drive Replacement" "medium" "$risk_details"; then
        return 1
    fi
    
    echo "✅ Safety checks completed and confirmed"
    return 0
}

#
# Step 3: Preparation - Prepare system for drive replacement
# $1: target position
#
replace_step_preparation() {
    local target_position="$1"
    
    echo ""
    echo "🛠️  Step 3: Preparation"
    echo "─────────────────────────────────────────────────────────────────────"
    
    # Check if drive is mounted and offer to unmount
    echo "🔍 Checking mount status..."
    if mount | grep -q "$REPLACE_TARGET_DEVICE"; then
        echo "⚠️  Drive $REPLACE_TARGET_DRIVE is currently mounted"
        
        if pooltool::question -p "Unmount the drive now?" -d "y"; then
            echo "📤 Unmounting $REPLACE_TARGET_DRIVE..."
            if sudo umount "$REPLACE_TARGET_DEVICE" 2>/dev/null; then
                echo "✅ Drive unmounted successfully"
            else
                echo "❌ Failed to unmount drive. You may need to stop services using it."
                if ! pooltool::question -p "Continue anyway?" -d "n"; then
                    return 1
                fi
            fi
        fi
    else
        echo "✅ Drive is not currently mounted"
    fi
    
    # Offer to blink the drive LED for identification
    echo ""
    echo "💡 Physical Drive Identification"
    if pooltool::question -p "Blink the LED on the target drive for identification?" -d "y"; then
        echo "🔆 Blinking LED on drive $REPLACE_TARGET_DRIVE..."
        blink_drive_led "$target_position" 30 || {
            echo "⚠️  LED blink command failed, but continuing with replacement"
        }
        
        echo "💡 The LED should be blinking on the drive to be replaced."
        echo "   Look for the blinking light in your drive bay."
        
        if ! pooltool::question -p "Can you see the blinking LED and identify the drive?" -d "y"; then
            echo "❌ Cannot proceed without physical drive identification"
            return 1
        fi
    fi
    
    # Create backup of critical information
    echo ""
    echo "💾 Creating replacement information backup..."
    local backup_file="/tmp/drive_replacement_${target_position}_$(date +%Y%m%d_%H%M%S).info"
    {
        echo "# Drive Replacement Information"
        echo "# Generated: $(date)"
        echo "Target Position: $target_position"
        echo "Drive Name: $REPLACE_TARGET_DRIVE"
        echo "Device Path: $REPLACE_TARGET_DEVICE"
        echo "Model: $REPLACE_TARGET_MODEL"
        echo ""
        echo "# Drive Information Before Replacement:"
        get_drive_info_by_position "$target_position" 2>/dev/null || echo "Drive info unavailable"
        echo ""
        echo "# Health Information:"
        pooltool health "$target_position" 2>/dev/null || echo "Health info unavailable"
    } > "$backup_file"
    
    echo "📋 Replacement information saved to: $backup_file"
    
    echo ""
    echo "✅ Preparation completed successfully"
    echo "📝 Ready for physical drive replacement"
    
    return 0
}

#
# Step 4: Physical Replacement - Guide through physical drive replacement
# $1: target position
#
replace_step_physical() {
    local target_position="$1"
    
    echo ""
    echo "🔧 Step 4: Physical Drive Replacement"
    echo "─────────────────────────────────────────────────────────────────────"
    
    echo "📋 Physical Replacement Instructions:"
    echo ""
    echo "1️⃣  BEFORE REMOVING THE OLD DRIVE:"
    echo "   • Ensure the LED is blinking (if enabled in previous step)"
    echo "   • Note the position - this is bay position $target_position"
    echo "   • Have your replacement drive ready"
    echo ""
    echo "2️⃣  REMOVING THE OLD DRIVE:"
    echo "   • Power down the drive bay if hot-swap is not supported"
    echo "   • Carefully disconnect SATA power and data cables"
    echo "   • Remove the drive from the bay"
    echo "   • Keep the old drive safe in case data recovery is needed"
    echo ""
    echo "3️⃣  INSTALLING THE NEW DRIVE:"
    echo "   • Insert the new drive into the same bay (position $target_position)"
    echo "   • Connect SATA power and data cables securely"
    echo "   • Ensure the drive is properly seated and secured"
    echo "   • Power on the drive bay if it was powered down"
    echo ""
    
    if ! pooltool::question -p "Have you completed the physical drive replacement?" -d "n"; then
        echo "❌ Physical replacement not completed - workflow paused"
        echo "💡 You can resume this workflow later by running:"
        echo "   pooltool replace-drive $target_position --resume"
        return 1
    fi
    
    # Wait for system to detect new drive
    echo ""
    echo "⏳ Waiting for system to detect the new drive..."
    sleep 5
    
    # Verify new drive is detected
    echo "🔍 Verifying new drive detection..."
    local detection_attempts=0
    local max_attempts=12  # 60 seconds total
    
    while [[ $detection_attempts -lt $max_attempts ]]; do
        if arcconf getconfig 1 >/dev/null 2>&1; then
            echo "✅ RAID controller responding"
            break
        fi
        
        echo "⏳ Waiting for RAID controller... (attempt $((detection_attempts + 1))/$max_attempts)"
        sleep 5
        ((detection_attempts++))
    done
    
    if [[ $detection_attempts -eq $max_attempts ]]; then
        echo "❌ RAID controller not responding after drive replacement"
        echo "💡 This may be normal - the controller might need more time"
        
        if ! pooltool::question -p "Continue anyway? The new drive might not be immediately visible" -d "y"; then
            return 1
        fi
    fi
    
    echo "✅ Physical replacement completed"
    echo "📝 Proceeding to data migration phase"
    
    return 0
}

#
# Step 5: Data Migration - Handle data migration or rebuild
# $1: target position
#
replace_step_migration() {
    local target_position="$1"
    
    echo ""
    echo "📦 Step 5: Data Migration"
    echo "─────────────────────────────────────────────────────────────────────"
    
    echo "🔍 Analyzing data migration options..."
    
    # Check if new drive is detected
    local new_drive_info
    if new_drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        local new_drive_name new_device_path new_model
        read -r new_drive_name new_device_path new_model <<< "$new_drive_info"
        
        echo "✅ New drive detected:"
        echo "   Drive: $new_drive_name"
        echo "   Device: $new_device_path" 
        echo "   Model: $new_model"
    else
        echo "⚠️  New drive not yet detected by the system"
        echo "💡 This may be normal immediately after replacement"
        
        if pooltool::question -p "Wait longer for drive detection?" -d "y"; then
            echo "⏳ Waiting additional time for drive detection..."
            sleep 15
            
            if new_drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
                local new_drive_name new_device_path new_model
                read -r new_drive_name new_device_path new_model <<< "$new_drive_info"
                echo "✅ New drive now detected: $new_drive_name"
            else
                echo "❌ New drive still not detected"
                echo "💡 You may need to:"
                echo "   • Check physical connections"
                echo "   • Restart the system"
                echo "   • Check RAID controller status"
                
                if ! pooltool::question -p "Continue with manual migration setup?" -d "n"; then
                    return 1
                fi
            fi
        fi
    fi
    
    echo ""
    echo "📋 Data Migration Options:"
    echo ""
    echo "1️⃣  SnapRAID Parity Rebuild (Recommended)"
    echo "   • Automatically rebuild data from parity information"
    echo "   • Safe and reliable for SnapRAID arrays"
    echo "   • Requires array to be in sync"
    echo ""
    echo "2️⃣  Manual Data Copy"
    echo "   • Copy data from backup or another source"
    echo "   • Full control over the process"
    echo "   • Requires manual setup and monitoring"
    echo ""
    echo "3️⃣  Skip Migration (New Empty Drive)"
    echo "   • Leave drive empty for new data"
    echo "   • Suitable for expansion or dedicated use"
    echo "   • No data recovery"
    echo ""
    
    local migration_choice
    migration_choice=$(bashful input -p "Choose migration method (1-3): " -d "1")
    
    case "$migration_choice" in
        "1")
            echo "🔄 Initiating SnapRAID parity rebuild..."
            replace_migration_snapraid_rebuild "$target_position"
            ;;
        "2")
            echo "📋 Setting up manual data copy..."
            replace_migration_manual_copy "$target_position"
            ;;
        "3")
            echo "📁 Configuring empty drive for new use..."
            replace_migration_new_empty "$target_position"
            ;;
        *)
            echo "❌ Invalid choice - defaulting to parity rebuild"
            replace_migration_snapraid_rebuild "$target_position"
            ;;
    esac
    
    echo "✅ Data migration phase completed"
    return 0
}

#
# Step 6: Validation - Final validation and integration
# $1: target position
#
replace_step_validation() {
    local target_position="$1"
    
    echo ""
    echo "✅ Step 6: Final Validation"
    echo "─────────────────────────────────────────────────────────────────────"
    
    echo "🔍 Running post-replacement validation..."
    
    # Validate new drive health
    echo ""
    echo "🏥 Health Validation:"
    if pooltool health "$target_position" --quiet; then
        echo "✅ New drive health check passed"
    else
        echo "⚠️  New drive health check failed or not yet available"
        echo "💡 This may be normal for a brand new drive"
    fi
    
    # Validate drive accessibility
    echo ""
    echo "📡 Accessibility Validation:"
    local new_drive_info
    if new_drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "✅ New drive is accessible and mapped correctly"
        echo "   Drive: $(echo "$new_drive_info" | awk '{print $1}')"
    else
        echo "❌ New drive not accessible - may need system restart"
    fi
    
    # Show updated drive layout
    echo ""
    echo "📊 Updated Drive Layout:"
    pooltool drivemap --numbered --health --capacity
    
    echo ""
    echo "📋 Replacement Summary:"
    echo "══════════════════════════════════════════════════════════════"
    echo "• Position: $target_position"
    echo "• Old Drive: $REPLACE_TARGET_DRIVE ($REPLACE_TARGET_MODEL)"
    echo "• Status: Replacement completed"
    echo "• Data Migration: Completed"
    echo "• Validation: Passed"
    
    echo ""
    echo "🎯 Next Steps:"
    echo "• Monitor the new drive for the first few days"
    echo "• Run a full SnapRAID scrub to verify data integrity"
    echo "• Update any drive documentation or labels"
    echo "• Consider running extended health tests"
    
    echo ""
    if pooltool::question -p "Mark replacement as fully validated and complete?" -d "y"; then
        echo "✅ Drive replacement validation completed successfully"
        return 0
    else
        echo "⚠️  Validation marked as incomplete - monitor manually"
        return 0
    fi
}

#
# Show detailed drive information during assessment
#
replace_show_drive_details() {
    local position="$1"
    local drive_name="$2"
    local device_path="$3"
    local model="$4"
    
    echo "🏷️  Drive Identity:"
    echo "   Position: $position"
    echo "   Name: $drive_name"
    echo "   Device: $device_path"
    echo "   Model: $model"
    
    # Get health information
    echo ""
    echo "🏥 Health Status:"
    if pooltool health "$position" 2>/dev/null; then
        echo "   ✅ Health data available"
    else
        echo "   ⚠️  Health data unavailable"
    fi
    
    # Get capacity information
    echo ""
    echo "💾 Capacity Information:"
    local capacity_info
    if capacity_info=$(df -h "$device_path"* 2>/dev/null | grep "$device_path"); then
        echo "   📊 $(echo "$capacity_info" | awk '{print "Used: " $3 "/" $2 " (" $5 ")"}')"
    else
        echo "   📊 Capacity information unavailable (drive may not be mounted)"
    fi
    
    # Check SnapRAID role
    echo ""
    echo "🗄️  Array Integration:"
    echo "   💡 SnapRAID role detection not yet implemented"
    echo "   💡 Check SnapRAID configuration for drive role"
}

#
# SnapRAID parity rebuild migration method (enhanced with disk command logic)
#
replace_migration_snapraid_rebuild() {
    local target_position="$1"
    
    echo "🔄 SnapRAID Parity Rebuild Method"
    echo "════════════════════════════════════════════════════════════════"
    
    # Check if this is a parity drive
    if [[ "$REPLACE_TARGET_DRIVE" =~ PPU[0-9]+ ]]; then
        echo "⚠️  PARITY DRIVE REPLACEMENT DETECTED"
        echo "Parity drives require different handling than data drives."
        echo ""
        echo "📋 Parity Drive Replacement Process:"
        echo "1. Update SnapRAID configuration with new drive"
        echo "2. Run: snapraid sync (to rebuild parity on new drive)"
        echo "3. Run: snapraid scrub (to verify integrity)"
        echo ""
    else
        echo "📋 Data Drive Replacement Process:"
        echo "1. Update SnapRAID configuration if needed"
        echo "2. Run: snapraid fix -d $REPLACE_TARGET_DRIVE"
        echo "3. Run: snapraid scrub -d $REPLACE_TARGET_DRIVE"
        echo ""
    fi
    
    echo "⚠️  SnapRAID Integration Notice:"
    echo "SnapRAID operations can take several hours to complete."
    echo "You can run them in the background and monitor progress."
    echo ""
    
    local run_background="false"
    if pooltool::question -p "Run SnapRAID operations in background?" -d "y"; then
        run_background="true"
    fi
    
    if [[ "$run_background" == "true" ]]; then
        echo "🔄 SnapRAID operations will run in background"
        echo "Use 'pooltool monitor' to track progress"
        this::start_snapraid_recovery_background "$REPLACE_TARGET_DRIVE"
        return 0
    else
        echo "⚠️  You will need to run SnapRAID commands manually:"
        if [[ "$REPLACE_TARGET_DRIVE" =~ PPU[0-9]+ ]]; then
            echo "  1. snapraid sync"
            echo "  2. snapraid scrub"
        else
            echo "  1. snapraid fix -d $REPLACE_TARGET_DRIVE"
            echo "  2. snapraid scrub -d $REPLACE_TARGET_DRIVE"
        fi
    fi
    
    if ! pooltool::question -p "Have you prepared for SnapRAID rebuild process?" -d "n"; then
        echo "⚠️  SnapRAID rebuild preparation not confirmed"
        return 1
    fi
    
    return 0
}

#
# Manual data copy migration method (enhanced with disk command rsync approach)
#
replace_migration_manual_copy() {
    local target_position="$1"
    
    echo "📋 Manual Data Copy Setup (Enhanced)"
    echo "════════════════════════════════════════════════════════════════"
    
    # Check if we have the old drive data available
    local old_mountpoint=""
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    local snapraid_names=( $(snapraid::devices names) )
    
    # Find the old drive's mount point
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$REPLACE_TARGET_DRIVE" ]]; then
            old_mountpoint="${snapraid_mountpoints[i]}"
            break
        fi
    done
    
    if [[ -n "$old_mountpoint" && -d "$old_mountpoint" ]]; then
        echo "✅ Old drive data found at: $old_mountpoint"
        echo ""
        
        if pooltool::question -p "Do you want to use automated rsync copy from the old drive?" -d "y"; then
            replace_migration_automated_rsync "$target_position" "$old_mountpoint"
            return $?
        fi
    else
        echo "⚠️  Old drive mount point not accessible: $old_mountpoint"
        echo "Proceeding with manual copy instructions."
    fi
    
    echo ""
    echo "📋 Manual Data Copy Instructions:"
    echo ""
    echo "1️⃣  Prepare the new drive:"
    echo "   • Partition: sudo sgdisk -n 0:0:0 -c 0:\"$REPLACE_TARGET_DRIVE\" -t 0:8300 /dev/NEW_DRIVE"
    echo "   • Format: sudo mkfs.ext4 -L \"$REPLACE_TARGET_DRIVE\" /dev/NEW_DRIVE1"
    echo "   • Mount: sudo mount /dev/NEW_DRIVE1 /mnt/replacement"
    echo ""
    echo "2️⃣  Copy data using rsync (from disk command proven method):"
    echo "   • Command: sudo rsync -haxHAWXS --numeric-ids --info=progress2 SOURCE/ /mnt/replacement/"
    echo "   • Flags explanation:"
    echo "     -h: Human-readable output"
    echo "     -a: Archive mode (preserve permissions, times, etc.)"
    echo "     -x: Don't cross filesystem boundaries"
    echo "     -H: Preserve hard links"
    echo "     -A: Preserve ACLs"
    echo "     -W: Copy whole files (no delta transfer)"
    echo "     -X: Preserve extended attributes"
    echo "     -S: Handle sparse files efficiently"
    echo "     --numeric-ids: Preserve numeric user/group IDs"
    echo "     --info=progress2: Show progress information"
    echo ""
    echo "3️⃣  Update system configuration:"
    echo "   • Update /etc/fstab with new drive UUID"
    echo "   • Update SnapRAID configuration"
    echo "   • Test mounting and accessibility"
    echo ""
    
    if ! pooltool::question -p "Have you completed the manual data copy setup?" -d "n"; then
        echo "⚠️  Manual copy not completed - marked for manual completion"
        return 1
    fi
    
    return 0
}

#
# Automated rsync copy method (based on disk command implementation)
#
replace_migration_automated_rsync() {
    local target_position="$1"
    local source_path="$2"
    local username="$(id -nu)"
    local runid="$(uuidgen)"
    
    echo "🔄 Automated Rsync Copy Process"
    echo "════════════════════════════════════════════════════════════════"
    echo "Source: $source_path"
    echo "Target: Will be prompted for new drive device"
    echo ""
    
    # Get new drive device path
    local new_drive_device
    while [[ -z "$new_drive_device" ]]; do
        new_drive_device=$(bashful input -p "Enter the new drive device path (e.g., /dev/sdi): " -d "")
        
        if [[ ! -b "$new_drive_device" ]]; then
            echo "❌ $new_drive_device is not a valid block device"
            new_drive_device=""
            continue
        fi
        
        # Remove any partition numbers
        new_drive_device="${new_drive_device%%[[:digit:]]}"
    done
    
    echo ""
    echo "🛠️  Preparing new drive..."
    
    # Check for existing partitions (based on disk command logic)
    local diskparts
    IFS=$'\n' read -d '' -ra diskparts <<< "$(lsblk -lo "TYPE,NAME,MOUNTPOINT" "$new_drive_device" | tail -n +2 | awk -v u="part" '$1 == u { print $2":"$3 }')"
    
    if [[ ${#diskparts[@]} -gt 0 ]]; then
        echo "⚠️  Drive has existing partitions:"
        for diskpart in "${diskparts[@]}"; do
            echo "   ${diskpart}"
        done
        
        echo ""
        echo "❌ Continuing will ERASE ALL DATA on $new_drive_device"
        if ! pooltool::question -p "Are you sure you want to continue?" -d "n"; then
            echo "❌ Operation cancelled"
            return 1
        fi
        
        # Unmount any mounted partitions
        local mountpoints=()
        for diskpart in "${diskparts[@]}"; do
            if [[ "${diskpart#*:}" != "" ]]; then
                mountpoints+=( "${diskpart#*:}" )
            fi
        done
        
        if [[ ${#mountpoints[@]} -gt 0 ]]; then
            echo "📤 Unmounting existing partitions..."
            snown::sudo umount "${mountpoints[@]}" 2>/dev/null || true
        fi
        
        # Clear partition table
        echo "🗑️  Clearing partition table..."
        snown::sudo sgdisk -Z "$new_drive_device"
    fi
    
    # Create new partition and filesystem
    echo "📝 Creating partition and filesystem..."
    snown::sudo sgdisk -n 0:0:0 -c 0:"$REPLACE_TARGET_DRIVE" -t 0:8300 "$new_drive_device"
    snown::sudo mkfs.ext4 -L "$REPLACE_TARGET_DRIVE" "${new_drive_device}1"
    
    # Create temporary mount point
    local temp_mountpoint="/media/${username}/${runid}"
    snown::sudo mkdir -p "$temp_mountpoint"
    snown::sudo mount -t ext4 "${new_drive_device}1" "$temp_mountpoint"
    snown::sudo chown "$username" "$temp_mountpoint"
    
    echo "✅ New drive prepared and mounted at: $temp_mountpoint"
    echo ""
    
    # Estimate copy time and size
    echo "📊 Analyzing source data..."
    local source_size=$(du -sh "$source_path" 2>/dev/null | awk '{print $1}')
    echo "Source data size: $source_size"
    echo ""
    
    # Confirm copy operation
    echo "🚀 Ready to start data copy:"
    echo "   Source: $source_path"
    echo "   Destination: $temp_mountpoint"
    echo "   Method: rsync with proven flags from disk command"
    echo ""
    echo "⏱️  This operation may take several hours depending on data size."
    echo "📧 You will receive email notification when complete (if configured)."
    echo ""
    
    if ! pooltool::question -p "Start the data copy now?" -d "y"; then
        echo "❌ Data copy cancelled"
        snown::sudo umount "$temp_mountpoint"
        snown::sudo rmdir "$temp_mountpoint"
        return 1
    fi
    
    # Save progress state (based on disk command)
    local progress_mark="replace_drive_copy_data"
    declare -p runid username new_drive_device source_path temp_mountpoint progress_mark > "${HOME}/.pooltool.replace.${runid}"
    
    echo "🔄 Starting background rsync copy..."
    echo "   Progress file: ${HOME}/.pooltool.replace.${runid}"
    echo "   Temp mount: $temp_mountpoint"
    echo ""
    
    # Start background rsync (enhanced from disk command)
    snown::sudo screen -dmS "replace_${runid}" bash -c "
        rsync -haxHAWXS --numeric-ids --info=progress2 \
            '$source_path/' '$temp_mountpoint/' && \
        echo 'Rsync completed successfully' > '$temp_mountpoint/.rsync_complete' || \
        echo 'Rsync failed with error $?' > '$temp_mountpoint/.rsync_error'
    "
    
    echo "✅ Background copy started with session: replace_${runid}"
    echo ""
    echo "📋 Monitor progress with:"
    echo "   screen -r replace_${runid}  # Attach to copy session"
    echo "   df -h $temp_mountpoint      # Check space usage"
    echo "   ls -la $temp_mountpoint     # Check files being copied"
    echo ""
    echo "💡 The copy will continue in the background. You can safely close this terminal."
    echo "   The wizard will check for completion when you proceed to the next step."
    
    # Store rsync session info globally
    REPLACE_RSYNC_RUNID="$runid"
    REPLACE_RSYNC_MOUNTPOINT="$temp_mountpoint"
    REPLACE_NEW_DEVICE="${new_drive_device}1"
    
    return 0
}

#
# New empty drive migration method
#
replace_migration_new_empty() {
    local target_position="$1"
    
    echo "📁 New Empty Drive Configuration:"
    echo "════════════════════════════════════════════════════════════════"
    echo "Setting up the new drive for fresh use..."
    echo ""
    echo "💡 The new drive will be available for:"
    echo "• New data storage"
    echo "• Array expansion"
    echo "• Dedicated application use"
    echo ""
    echo "📋 Recommended next steps:"
    echo "• Partition and format the drive as needed"
    echo "• Add to SnapRAID configuration if desired"
    echo "• Configure mounting in /etc/fstab"
    echo "• Run health checks to ensure drive stability"
    
    if pooltool::question -p "Configure the drive for immediate use?" -d "y"; then
        echo "🛠️  Basic drive preparation would go here"
        echo "💡 Full drive preparation tools will be added in future versions"
    fi
    
    return 0
}

# Initialize drive replacement wizard
replace_drive_init

#
# Upgrade workflow step functions
#

#
# Upgrade Step 1: Assess source drive for upgrade
#
replace_upgrade_step_source_assessment() {
    local target_position="$1"
    
    echo "📊 Step 1: Source Drive Assessment for Upgrade"
    echo "─────────────────────────────────────────────────────────────────────"
    
    # Show current drive layout
    echo "Current Drive Layout:"
    
    # Use a simpler, non-blocking drive overview for the wizard
    echo "📋 Quick Drive Overview:"
    echo "   Checking SnapRAID configuration..."
    
    # Get SnapRAID drive count without expensive operations
    local snapraid_names=( $(snapraid::devices names 2>/dev/null || echo) )
    local drive_count=${#snapraid_names[@]}
    
    if [[ $drive_count -gt 0 ]]; then
        echo "   ✅ SnapRAID array detected with $drive_count drives"
        echo "   📍 For detailed drive layout, run: pooltool drivemap"
    else
        echo "   ⚠️  No SnapRAID configuration detected"
    fi
    
    echo ""
    
    # Get source drive selection if not provided
    if [[ -z "$target_position" ]]; then
        echo "📋 Which drive would you like to upgrade?"
        echo ""
        
        while true; do
            local user_input
            user_input=$(bashful input -p "Enter the position number (1-24) of the drive to upgrade: " -d "")
            
            if [[ "$user_input" == "q" || "$user_input" == "quit" ]]; then
                echo "❌ Drive upgrade cancelled by user"
                return 1
            elif [[ "$user_input" =~ ^[0-9]+$ ]] && [[ $user_input -ge 1 ]] && [[ $user_input -le 24 ]]; then
                target_position="$user_input"
                break
            else
                echo "❌ Invalid position. Please enter a number between 1 and 24, or 'q' to quit."
            fi
        done
    fi
    
    # Validate source drive exists and is accessible
    local drive_info
    if ! drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "❌ No drive found at position $target_position"
        return 1
    fi
    
    # Parse drive information  
    local drive_name device_path model
    read -r drive_name device_path model <<< "$drive_info"
    
    # Check if drive is currently accessible
    if [[ ! -b "$device_path" ]]; then
        echo "❌ Source drive $device_path is not accessible"
        echo "💡 This might be a failed drive - consider using recovery workflow instead"
        return 1
    fi
    
    echo "📊 Source Drive Analysis:"
    echo "══════════════════════════════════════════════════════════════"
    
    # Show detailed source drive information
    replace_show_drive_details "$target_position" "$drive_name" "$device_path" "$model"
    replace_show_snapraid_integration "$drive_name"
    
    # Determine drive type for upgrade considerations
    local drive_type="data"
    if [[ "$drive_name" =~ PPU[0-9]+ ]]; then
        drive_type="parity"
        echo ""
        echo "⚠️  PARITY DRIVE UPGRADE DETECTED"
        echo "Parity drives require special considerations:"
        echo "• Parity drives can be safely upgraded with direct copy"
        echo "• New drive must be same size or larger"
        echo "• SnapRAID will need to rebuild parity after upgrade"
    fi
    
    # Check current health status
    echo ""
    echo "🏥 Health Check:"
    if pooltool health "$target_position" --quiet 2>/dev/null; then
        echo "✅ Source drive is healthy and accessible"
    else
        echo "⚠️  Source drive has health issues or is not accessible"
        echo "💡 Consider using recovery workflow for failed drives"
        
        if ! pooltool::question -p "Continue with upgrade despite health warnings?" -d "n"; then
            echo "❌ Upgrade cancelled due to health concerns"
            return 1
        fi
    fi
    
    # Store source drive information globally
    REPLACE_TARGET_POSITION="$target_position"
    REPLACE_TARGET_DRIVE="$drive_name"
    REPLACE_TARGET_DEVICE="$device_path"
    REPLACE_TARGET_MODEL="$model"
    REPLACE_DRIVE_TYPE="$drive_type"
    
    echo ""
    echo "✅ Source drive assessment completed - Ready for upgrade planning"
    return 0
}

#
# Upgrade Step 2: Prepare new drive and validate compatibility
#
replace_upgrade_step_new_drive_prep() {
    echo ""
    echo "💽 Step 2: New Drive Preparation"
    echo "─────────────────────────────────────────────────────────────────────"
    
    echo "📋 New Drive Requirements:"
    echo "• Must be same size or larger than source drive"
    echo "• Should be connected and accessible before proceeding"
    echo "• Will be partitioned and formatted during this process"
    echo ""
    
    # Get source drive size for comparison
    local source_size=""
    if [[ -b "$REPLACE_TARGET_DEVICE" ]]; then
        source_size=$(lsblk -bno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
        local source_size_human=$(lsblk -hno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
        echo "📏 Source drive size: $source_size_human"
    fi
    
    echo ""
    echo "🔍 Available drives for upgrade:"
    
    # Show available drives (excluding current SnapRAID drives)
    local snapraid_volumes=( $(snapraid::devices volumes) )
    local available_drives=()
    
    # Get all block devices
    while IFS= read -r drive; do
        # Skip if it's already in SnapRAID array
        local skip=false
        for snapraid_volume in "${snapraid_volumes[@]}"; do
            if [[ "$drive" == "$snapraid_volume" ]]; then
                skip=true
                break
            fi
        done
        
        if [[ "$skip" == false && "$drive" != "$REPLACE_TARGET_DEVICE" ]]; then
            available_drives+=("$drive")
        fi
    done < <(lsblk -plno NAME,TYPE | awk '$2=="disk" {print $1}')
    
    if [[ ${#available_drives[@]} -eq 0 ]]; then
        echo "❌ No available drives found for upgrade"
        echo "💡 Please connect your new drive and try again"
        return 1
    fi
    
    # Show available drives with sizes
    echo "Available drives:"
    for drive in "${available_drives[@]}"; do
        local size_human=$(lsblk -hno SIZE "$drive" | head -1)
        local size_bytes=$(lsblk -bno SIZE "$drive" | head -1)
        local model=$(lsblk -no MODEL "$drive" | head -1 | xargs)
        
        # Check if drive is large enough
        local size_status="✅"
        if [[ -n "$source_size" && $size_bytes -lt $source_size ]]; then
            size_status="❌ TOO SMALL"
        fi
        
        printf "  %-12s %-8s %-20s %s\n" "$drive" "$size_human" "$model" "$size_status"
    done
    
    echo ""
    
    # Get new drive selection
    local new_drive=""
    while [[ -z "$new_drive" ]]; do
        local user_input
        user_input=$(bashful input -p "Enter the new drive device path (e.g., /dev/sdi): " -d "")
        
        if [[ "$user_input" == "q" || "$user_input" == "quit" ]]; then
            echo "❌ New drive selection cancelled"
            return 1
        fi
        
        # Validate input
        if [[ ! -b "$user_input" ]]; then
            echo "❌ $user_input is not a valid block device"
            continue
        fi
        
        # Check if it's in available drives
        local found=false
        for drive in "${available_drives[@]}"; do
            if [[ "$drive" == "$user_input" ]]; then
                found=true
                break
            fi
        done
        
        if [[ "$found" == false ]]; then
            echo "❌ Drive $user_input is not available for upgrade (may be in use)"
            continue
        fi
        
        # Check size compatibility
        if [[ -n "$source_size" ]]; then
            local new_size=$(lsblk -bno SIZE "$user_input" | head -1)
            if [[ $new_size -lt $source_size ]]; then
                echo "❌ New drive is smaller than source drive"
                echo "   Source: $(lsblk -hno SIZE "$REPLACE_TARGET_DEVICE" | head -1)"
                echo "   New: $(lsblk -hno SIZE "$user_input" | head -1)"
                
                if ! pooltool::question -p "Continue anyway? (NOT RECOMMENDED)" -d "n"; then
                    continue
                fi
            fi
        fi
        
        new_drive="$user_input"
    done
    
    # Store new drive information
    REPLACE_NEW_DEVICE="$new_drive"
    REPLACE_NEW_SIZE=$(lsblk -hno SIZE "$new_drive" | head -1)
    REPLACE_NEW_MODEL=$(lsblk -no MODEL "$new_drive" | head -1 | xargs)
    
    echo ""
    echo "✅ New drive selected: $new_drive"
    echo "   Model: $REPLACE_NEW_MODEL"
    echo "   Size: $REPLACE_NEW_SIZE"
    echo ""
    echo "📝 Ready for compatibility verification"
    
    return 0
}

#
# Upgrade Step 3: Verify capacity and compatibility
#
replace_upgrade_step_compatibility_check() {
    echo ""
    echo "🔍 Step 3: Capacity and Compatibility Check"
    echo "─────────────────────────────────────────────────────────────────────"
    
    echo "📊 Upgrade Compatibility Analysis:"
    echo ""
    printf "%-15s %-15s %-20s %-10s\n" "Component" "Source" "New" "Status"
    printf "%-15s %-15s %-20s %-10s\n" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 20 '' | tr ' ' '-')" "$(printf '%*s' 10 '' | tr ' ' '-')"
    
    # Size comparison
    local source_size_human=$(lsblk -hno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
    local size_status="✅ OK"
    
    local source_size_bytes=$(lsblk -bno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
    local new_size_bytes=$(lsblk -bno SIZE "$REPLACE_NEW_DEVICE" | head -1)
    
    if [[ $new_size_bytes -lt $source_size_bytes ]]; then
        size_status="❌ SMALLER"
    elif [[ $new_size_bytes -gt $source_size_bytes ]]; then
        size_status="✅ LARGER"
    fi
    
    printf "%-15s %-15s %-20s %-10s\n" "Drive Size" "$source_size_human" "$REPLACE_NEW_SIZE" "$size_status"
    printf "%-15s %-15s %-20s %-10s\n" "Model" "$REPLACE_TARGET_MODEL" "$REPLACE_NEW_MODEL" "✅ OK"
    printf "%-15s %-15s %-20s %-10s\n" "Drive Type" "$REPLACE_DRIVE_TYPE" "$REPLACE_DRIVE_TYPE" "✅ SAME"
    
    # Check for existing partitions on new drive
    echo ""
    echo "🔍 New Drive Partition Check:"
    
    local partitions
    partitions=$(lsblk -lno NAME,TYPE "$REPLACE_NEW_DEVICE" | awk '$2=="part" {print $1}')
    
    if [[ -n "$partitions" ]]; then
        echo "⚠️  New drive has existing partitions:"
        lsblk "$REPLACE_NEW_DEVICE"
        echo ""
        echo "❌ CONTINUING WILL ERASE ALL DATA ON THE NEW DRIVE"
        
        if ! pooltool::question -p "Are you sure you want to erase the new drive?" -d "n"; then
            echo "❌ Compatibility check cancelled"
            return 1
        fi
    else
        echo "✅ New drive is clean (no existing partitions)"
    fi
    
    # Estimate copy time
    echo ""
    echo "⏱️  Upgrade Time Estimation:"
    
    local source_used=""
    if mount | grep -q "$REPLACE_TARGET_DEVICE"; then
        source_used=$(df -h "$REPLACE_TARGET_DEVICE"* 2>/dev/null | tail -1 | awk '{print $3}')
        echo "   Data to copy: $source_used"
        echo "   Estimated time: 2-8 hours (depends on data size and drive speed)"
    else
        echo "   Cannot estimate - source drive not mounted"
        echo "   Estimated time: 4-12 hours (full drive copy)"
    fi
    
    echo ""
    echo "🎯 Upgrade Summary:"
    echo "   Source: $REPLACE_TARGET_DRIVE ($REPLACE_TARGET_MODEL, $source_size_human)"
    echo "   Target: $REPLACE_NEW_DEVICE ($REPLACE_NEW_MODEL, $REPLACE_NEW_SIZE)"
    echo "   Method: Direct rsync copy with background processing"
    echo "   Risk Level: 🟢 LOW (source drive remains untouched)"
    
    echo ""
    if ! pooltool::question -p "Proceed with this upgrade configuration?" -d "y"; then
        echo "❌ Compatibility check failed - user cancelled"
        return 1
    fi
    
    echo "✅ Compatibility check passed - Ready for data copy"
    return 0
}

#
# Upgrade Step 5: Perform the data copy
#
replace_upgrade_step_data_copy() {
    echo ""
    echo "📦 Step 5: Data Copy Process"
    echo "─────────────────────────────────────────────────────────────────────"
    
    # This will use the enhanced automated rsync from the migration functions
    # but adapted for the upgrade workflow
    
    echo "🔄 Starting automated data copy from source to new drive..."
    echo "   Source: $REPLACE_TARGET_DEVICE"
    echo "   Target: $REPLACE_NEW_DEVICE"
    echo ""
    
    # Call the automated rsync function with upgrade-specific parameters
    local source_mountpoint=""
    
    # Find source drive mount point
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    local snapraid_names=( $(snapraid::devices names) )
    
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$REPLACE_TARGET_DRIVE" ]]; then
            source_mountpoint="${snapraid_mountpoints[i]}"
            break
        fi
    done
    
    if [[ -z "$source_mountpoint" || ! -d "$source_mountpoint" ]]; then
        echo "❌ Cannot find source drive mount point"
        echo "💡 Source drive may not be properly mounted"
        return 1
    fi
    
    echo "✅ Source mount point found: $source_mountpoint"
    
    # Use the automated rsync function
    replace_migration_automated_rsync "$REPLACE_TARGET_POSITION" "$source_mountpoint"
    return $?
}

#
# Upgrade Step 6: Perform the drive swap
#
replace_upgrade_step_drive_swap() {
    echo ""
    echo "🔄 Step 6: Drive Swap Process"
    echo "─────────────────────────────────────────────────────────────────────"
    
    echo "📋 Drive Swap Instructions:"
    echo ""
    echo "🔍 Current Configuration:"
    echo "   Source drive: $REPLACE_TARGET_DRIVE at position $REPLACE_TARGET_POSITION"
    echo "   New drive: $REPLACE_NEW_DEVICE (currently connected for copy)"
    echo ""
    echo "🔄 Swap Process:"
    echo "1️⃣  Unmount the source drive from SnapRAID"
    echo "2️⃣  Update SnapRAID configuration"  
    echo "3️⃣  Mount the new drive in place of the old drive"
    echo "4️⃣  Update system mount points (/etc/fstab)"
    echo ""
    
    # Check if rsync copy completed
    if [[ -n "$REPLACE_RSYNC_MOUNTPOINT" && -f "$REPLACE_RSYNC_MOUNTPOINT/.rsync_complete" ]]; then
        echo "✅ Data copy completed successfully"
    elif [[ -n "$REPLACE_RSYNC_MOUNTPOINT" && -f "$REPLACE_RSYNC_MOUNTPOINT/.rsync_error" ]]; then
        echo "❌ Data copy failed - cannot proceed with swap"
        echo "💡 Check the error and retry the copy process"
        return 1
    else
        echo "⚠️  Cannot verify data copy completion"
        if ! pooltool::question -p "Proceed anyway?" -d "n"; then
            return 1
        fi
    fi
    
    echo ""
    echo "⚠️  IMPORTANT: This step requires careful attention"
    echo "• Ensure data copy is complete and verified"
    echo "• Have the SnapRAID configuration ready to update"
    echo "• Be prepared to update /etc/fstab with new drive UUID"
    
    echo ""
    if ! pooltool::question -p "Are you ready to perform the drive swap?" -d "n"; then
        echo "❌ Drive swap cancelled"
        return 1
    fi
    
    echo ""
    echo "🚧 DRIVE SWAP IMPLEMENTATION IN PROGRESS"
    echo "This advanced step will be fully automated in the next iteration."
    echo ""
    echo "📋 Manual steps for now:"
    echo "1. Update SnapRAID config to point to new drive"
    echo "2. Update /etc/fstab with new drive UUID"
    echo "3. Unmount old drive and mount new drive"
    echo "4. Test accessibility and run SnapRAID sync"
    
    if ! pooltool::question -p "Have you completed the manual drive swap?" -d "n"; then
        echo "⚠️  Drive swap not completed - marked for manual completion"
    fi
    
    return 0
}

#
# Add drive workflow step functions  
#
replace_add_step_capacity_assessment() {
    echo "📊 Add drive assessment implementation coming soon..."
    echo "This will assess current array capacity and recommend drive sizes."
    
    return 0
}

replace_add_step_integration() {
    echo "🔗 Drive integration implementation coming soon..."
    echo "This will integrate new drives with SnapRAID configuration."
    
    return 0
}

#
# Common utility functions used across all workflows
#

#
# Show detailed information about a drive
#
replace_show_drive_details() {
    local position="$1"
    local drive_name="$2"
    local device_path="$3"
    local model="$4"
    
    printf "%-15s %s\n" "Position:" "$position"
    printf "%-15s %s\n" "Drive Name:" "$drive_name"
    printf "%-15s %s\n" "Device Path:" "$device_path"
    printf "%-15s %s\n" "Model:" "$model"
    
    if [[ -b "$device_path" ]]; then
        local size_human=$(lsblk -hno SIZE "$device_path" | head -1)
        local filesystem=$(lsblk -no FSTYPE "$device_path"* | head -1 | xargs)
        
        printf "%-15s %s\n" "Size:" "$size_human"
        [[ -n "$filesystem" ]] && printf "%-15s %s\n" "Filesystem:" "$filesystem"
        
        # Show mount status
        local mount_info
        mount_info=$(mount | grep "$device_path" | head -1)
        if [[ -n "$mount_info" ]]; then
            local mount_point=$(echo "$mount_info" | awk '{print $3}')
            printf "%-15s %s\n" "Mounted:" "$mount_point"
            
            # Show usage if mounted
            local usage_info
            usage_info=$(df -h "$mount_point" 2>/dev/null | tail -1)
            if [[ -n "$usage_info" ]]; then
                local used=$(echo "$usage_info" | awk '{print $3}')
                local available=$(echo "$usage_info" | awk '{print $4}')
                local use_percent=$(echo "$usage_info" | awk '{print $5}')
                
                printf "%-15s %s used, %s available (%s)\n" "Usage:" "$used" "$available" "$use_percent"
            fi
        else
            printf "%-15s %s\n" "Mounted:" "No"
        fi
    else
        printf "%-15s %s\n" "Status:" "❌ Not accessible"
    fi
}

#
# Show SnapRAID integration details for a drive
#
replace_show_snapraid_integration() {
    local drive_name="$1"
    
    echo ""
    echo "🛡️  SnapRAID Integration:"
    
    # Check if drive is in SnapRAID config
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_paths=( $(snapraid::devices mountpoints) )
    local snapraid_found=false
    local drive_index=""
    
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$drive_name" ]]; then
            snapraid_found=true
            drive_index=$i
            break
        fi
    done
    
    if [[ "$snapraid_found" == true ]]; then
        echo "✅ Drive is configured in SnapRAID array"
        printf "%-15s %s\n" "SnapRAID Path:" "${snapraid_paths[drive_index]}"
        
        # Check for parity drive
        if [[ "$drive_name" =~ PPU[0-9]+ ]]; then
            echo "🛡️  Drive Type: Parity Drive"
            echo "💡 Parity drives protect other drives in the array"
        else
            echo "📦 Drive Type: Data Drive"
            echo "💡 Data drives contain your actual files"
        fi
        
        # Show last SnapRAID sync status
        echo ""
        echo "📅 Last SnapRAID Status:"
        if command -v snapraid >/dev/null 2>&1; then
            # Try to get status (non-blocking)
            timeout 5s snapraid status 2>/dev/null | grep -E "(Everything OK|WARNING|ERROR)" | head -3 || echo "   Status check timed out"
        else
            echo "   SnapRAID command not available"
        fi
    else
        echo "❌ Drive is NOT in SnapRAID array"
        echo "� This drive is not protected by SnapRAID parity"
    fi
}

#
# Get drive information by position using driveutils unified mapping
#
get_drive_info_by_position() {
    local position="$1"
    
    # Convert position number (1-24) to connector/device coordinates
    # Position formula: connector * 4 + (4 - device) = position
    # Reverse: connector = (position - 1) / 4, device = 4 - ((position - 1) % 4) - 1
    
    local connector=$(( (position - 1) / 4 ))
    local device=$(( 4 - ((position - 1) % 4) - 1 ))
    
    # Load driveutils module to access unified mapping function
    bootstrap_load_module pooltool/driveutils >/dev/null 2>&1
    
    # Get unified mapping data 
    local unified_data
    if ! unified_data=$(pooltool::create_unified_mapping 1 2>/dev/null); then
        echo "UNKNOWN /dev/unknown Unknown_Model"
        return 1
    fi
    
    # Parse unified data to find drive at this connector/device position
    while IFS= read -r record; do
        if [[ -n "$record" ]]; then
            # Parse record: name:arcconf_id:connector:device_slot:snapraid_name:device_path:wwn:serial:channel:device_num:model:size:match_method
            if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
                local drive_name="${BASH_REMATCH[1]}"
                local arcconf_id="${BASH_REMATCH[2]}"
                local rec_connector="${BASH_REMATCH[3]}"
                local rec_device="${BASH_REMATCH[4]}"
                local snapraid_name="${BASH_REMATCH[5]}"
                local device_path="${BASH_REMATCH[6]}"
                local wwn="${BASH_REMATCH[7]}"
                local serial="${BASH_REMATCH[8]}"
                local channel="${BASH_REMATCH[9]}"
                local device_num="${BASH_REMATCH[10]}"
                local model="${BASH_REMATCH[11]}"
                local size="${BASH_REMATCH[12]}"
                local match_method="${BASH_REMATCH[13]}"
                
                # Check if this matches our target position
                if [[ $rec_connector -eq $connector && $rec_device -eq $device ]]; then
                    # For unallocated drives, device_path might be "NONE"
                    if [[ "$device_path" == "NONE" ]]; then
                        device_path="/dev/unknown"
                    fi
                    
                    # Return the drive information
                    echo "$drive_name $device_path $model"
                    return 0
                fi
            fi
        fi
    done <<< "$unified_data"
    
    # No drive found at this position
    return 1
}

#================================================================
# Background Process Functions
#================================================================

#
# Start SnapRAID recovery operations in background
#
start_snapraid_recovery_background() {
    local target_drive="$1"
    
    # Load background process manager
    bootstrap_load_module pooltool/background/process_manager
    bootstrap_load_module pooltool/background/notifications
    
    local operation_id=$(pooltool::background::process_manager::generate_operation_id "drive-recovery")
    local log_dir="/var/log/pooltool"
    local log_file="${log_dir}/${operation_id}.log"
    
    # Ensure log directory exists
    mkdir -p "$log_dir" 2>/dev/null || {
        log_dir="${HOME}/.pooltool/logs"
        log_file="${log_dir}/${operation_id}.log"
        mkdir -p "$log_dir"
    }
    
    echo ""
    echo "🚀 STARTING BACKGROUND RECOVERY"
    echo "═══════════════════════════════════════════════════════════════════"
    echo "Operation ID: $operation_id"
    echo "Target Drive: $target_drive"
    echo "Log File: $log_file"
    echo ""
    
    # Determine if this is a parity or data drive
    local command=""
    if [[ "$target_drive" =~ PPU[0-9]+ ]]; then
        echo "📋 Parity drive recovery process will:"
        echo "  1. Run 'snapraid sync' to rebuild parity"
        echo "  2. Run 'snapraid scrub' to verify integrity"
        command="this::snapraid_parity_recovery '$target_drive' '$operation_id'"
    else
        echo "📋 Data drive recovery process will:"
        echo "  1. Run 'snapraid fix -d $target_drive' to restore data"
        echo "  2. Run 'snapraid scrub -d $target_drive' to verify integrity"
        command="this::snapraid_data_recovery '$target_drive' '$operation_id'"
    fi
    
    echo ""
    echo "⏱️  Estimated time: 2-8 hours (depends on drive size and system)"
    echo "📊 Monitor progress: pooltool monitor show $operation_id"
    echo "📋 View live logs: pooltool monitor logs $operation_id --follow"
    echo ""
    
    if ! pooltool::question -p "Start background recovery process?" -d "y"; then
        echo "❌ Background recovery cancelled"
        return 1
    fi
    
    # Start the background process
    local started_id=$(pooltool::background::process_manager::start_background_process \
        "drive-recovery" \
        "$operation_id" \
        "$command" \
        "$log_file")
    
    if [[ -n "$started_id" ]]; then
        echo "✅ Background recovery started successfully!"
        echo ""
        echo "📋 NEXT STEPS:"
        echo "  • Monitor: pooltool monitor show $operation_id"
        echo "  • Live logs: pooltool monitor logs $operation_id --follow"
        echo "  • Wait for completion: pooltool monitor wait $operation_id"
        echo ""
        echo "🔔 You will be notified when the recovery completes."
        echo "   (Configure notifications in ~/.pooltool/notifications.conf)"
        
        # Send initial notification
        pooltool::background::notifications::send_notification \
            "$operation_id" \
            "started" \
            "medium" \
            "SnapRAID Recovery Started" \
            "Drive recovery for $target_drive has begun. This may take several hours."
            
        return 0
    else
        echo "❌ Failed to start background recovery"
        return 1
    fi
}

#
# SnapRAID data drive recovery process
#
snapraid_data_recovery() {
    local target_drive="$1"
    local operation_id="$2"
    
    echo "$(date): Starting data recovery for drive $target_drive" >&2
    echo "$(date): Running snapraid fix -d $target_drive" >&2
    
    # Update progress
    pooltool::background::process_manager::update_process_state \
        "$operation_id" "running" "Running snapraid fix" "" "25" "100"
    
    if snapraid fix -d "$target_drive"; then
        echo "$(date): SnapRAID fix completed successfully" >&2
        
        # Update progress
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "running" "Running snapraid scrub" "" "75" "100"
        
        echo "$(date): Running snapraid scrub -d $target_drive" >&2
        
        if snapraid scrub -d "$target_drive"; then
            echo "$(date): SnapRAID scrub completed successfully" >&2
            
            # Update to completed
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "completed" "Recovery completed successfully" "" "100" "100"
            
            # Send completion notification
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "completed"
            
            return 0
        else
            echo "$(date): SnapRAID scrub failed" >&2
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "failed" "SnapRAID scrub failed"
            
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "failed"
            
            return 1
        fi
    else
        echo "$(date): SnapRAID fix failed" >&2
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "failed" "SnapRAID fix failed"
        
        pooltool::background::notifications::notify_operation_complete \
            "$operation_id" "failed"
        
        return 1
    fi
}

#
# SnapRAID parity drive recovery process  
#
snapraid_parity_recovery() {
    local target_drive="$1"
    local operation_id="$2"
    
    echo "$(date): Starting parity recovery for drive $target_drive" >&2
    echo "$(date): Running snapraid sync" >&2
    
    # Update progress
    pooltool::background::process_manager::update_process_state \
        "$operation_id" "running" "Running snapraid sync" "" "25" "100"
    
    if snapraid sync; then
        echo "$(date): SnapRAID sync completed successfully" >&2
        
        # Update progress  
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "running" "Running snapraid scrub" "" "75" "100"
        
        echo "$(date): Running snapraid scrub" >&2
        
        if snapraid scrub; then
            echo "$(date): SnapRAID scrub completed successfully" >&2
            
            # Update to completed
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "completed" "Parity recovery completed successfully" "" "100" "100"
            
            # Send completion notification
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "completed"
            
            return 0
        else
            echo "$(date): SnapRAID scrub failed" >&2
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "failed" "SnapRAID scrub failed"
            
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "failed"
            
            return 1
        fi
    else
        echo "$(date): SnapRAID sync failed" >&2
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "failed" "SnapRAID sync failed"
        
        pooltool::background::notifications::notify_operation_complete \
            "$operation_id" "failed"
        
        return 1
    fi
}

#
# Helper function to convert number to character
#
chr() {
    printf "\\$(printf '%03o' "$1")"
}

#
# Progress tracking functions for rsync operations
#
replace_rsync_progress_monitor() {
    local rsync_pid="$1"
    local source_path="$2"
    local target_path="$3"
    
    echo "📊 Monitoring rsync progress (PID: $rsync_pid)..."
    
    while kill -0 "$rsync_pid" 2>/dev/null; do
        # Monitor target directory size
        if [[ -d "$target_path" ]]; then
            local source_size=$(du -sb "$source_path" 2>/dev/null | cut -f1)
            local target_size=$(du -sb "$target_path" 2>/dev/null | cut -f1)
            
            if [[ -n "$source_size" && -n "$target_size" && $source_size -gt 0 ]]; then
                local percent=$((target_size * 100 / source_size))
                echo "Progress: ${percent}% copied ($(numfmt --to=iec $target_size) / $(numfmt --to=iec $source_size))"
            fi
        fi
        
        sleep 30
    done
    
    echo "✅ Rsync process completed"
}
