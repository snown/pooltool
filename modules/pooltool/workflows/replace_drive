#!/bin/bash

# Pooltool Drive Replacement Wizard - Guided drive replacement workflow
# Part of Phase 3.2: Advanced Workflows
# Created: September 4, 2025

NAMESPACE="global"

# Drive replacement workflow steps
declare -gr REPLACE_STEP_ASSESSMENT=1
declare -gr REPLACE_STEP_SAFETY=2
declare -gr REPLACE_STEP_PREPARATION=3
declare -gr REPLACE_STEP_PHYSICAL=4
declare -gr REPLACE_STEP_MIGRATION=5
declare -gr REPLACE_STEP_VALIDATION=6
declare -gr REPLACE_TOTAL_STEPS=6

#
# Initialize drive replacement wizard
#
replace_drive_init() {
    # Load required modules
    bootstrap_load_module pooltool/workflows/workflow_engine
    bootstrap_load_module pooltool/workflows/safety_checks
    bootstrap_load_module pooltool/driveutils
    bootstrap_load_module pooltool/healthutils
    bootstrap_load_module pooltool/capacityutils
    bootstrap_load_module pooltool/ask_question
    bootstrap_load_module pooltool/commands/blink
    
    # Load SnapRAID integration modules from existing disk command
    bootstrap_load_module snapraid/devices
    bootstrap_load_module snown/script_sudo
    
    return 0
}

#
# Main drive replacement wizard entry point - Unified data management wizard
# Now supports: Adding drives, Upgrading drives, Replacing failed drives
#
replace_drive_wizard() {
    local target_position="$1"
    local operation_mode="$2"  # upgrade, recovery, add, or empty for interactive
    
    echo "ÔøΩ DRIVE MANAGEMENT WIZARD"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "This wizard will guide you through drive management operations with"
    echo "comprehensive safety checks and step-by-step guidance."
    echo ""
    
    # Step 0: Determine operation type if not specified
    local operation_type=""
    if [[ -z "$operation_mode" ]]; then
        operation_type=$(replace_determine_operation_type)
        if [[ $? -ne 0 ]]; then
            echo "‚ùå Operation cancelled by user"
            return 1
        fi
    else
        operation_type="$operation_mode"
    fi
    
    echo "üìã Operation Selected: $operation_type"
    echo ""
    
    # Start appropriate workflow based on operation type
    case "$operation_type" in
        "upgrade")
            replace_workflow_upgrade "$target_position"
            ;;
        "recovery")
            replace_workflow_recovery "$target_position"
            ;;
        "add")
            replace_workflow_add_drive "$target_position"
            ;;
        *)
            echo "‚ùå Unknown operation type: $operation_type"
            return 1
            ;;
    esac
    
    return $?
}

#
# Step 0: Determine what the user wants to do
#
replace_determine_operation_type() {
    echo "ü§î What would you like to do?" >&2
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" >&2
    echo "" >&2
    echo "Please select your goal:" >&2
    echo "" >&2
    echo "1Ô∏è‚É£  üìà UPGRADE A DRIVE" >&2
    echo "   ‚Ä¢ Replace a working drive with a larger or better drive" >&2
    echo "   ‚Ä¢ Both old and new drives will be connected during process" >&2
    echo "   ‚Ä¢ Direct data copy from old drive to new drive" >&2
    echo "   ‚Ä¢ Low risk - old drive remains as backup" >&2
    echo "   ‚Ä¢ Best for: capacity upgrades, newer/faster drives" >&2
    echo "" >&2
    echo "2Ô∏è‚É£  üö® REPLACE A FAILED DRIVE" >&2
    echo "   ‚Ä¢ Replace a drive that has failed or is failing" >&2
    echo "   ‚Ä¢ Old drive may be inaccessible or removed" >&2
    echo "   ‚Ä¢ Data restored from SnapRAID parity" >&2
    echo "   ‚Ä¢ Medium risk - depends on parity integrity" >&2
    echo "   ‚Ä¢ Best for: drive failures, critical SMART errors" >&2
    echo "" >&2
    echo "3Ô∏è‚É£  ‚ûï ADD A NEW DRIVE" >&2
    echo "   ‚Ä¢ Add a brand new drive to expand storage" >&2
    echo "   ‚Ä¢ No data migration needed" >&2
    echo "   ‚Ä¢ Configure for SnapRAID integration" >&2
    echo "   ‚Ä¢ Low risk - no existing data involved" >&2
    echo "   ‚Ä¢ Best for: expanding array capacity" >&2
    echo "" >&2
    
    while true; do
        local choice
        choice=$(bashful input -p "Enter your choice (1-3) or 'q' to quit: " -d "")
        
        case "$choice" in
            "1")
                echo "upgrade"
                return 0
                ;;
            "2")
                echo "recovery"
                return 0
                ;;
            "3")
                echo "add"
                return 0
                ;;
            "q"|"quit")
                return 1
                ;;
            *)
                echo "‚ùå Invalid choice. Please enter 1, 2, 3, or 'q' to quit." >&2
                ;;
        esac
    done
}

#
# Upgrade workflow: Replace working drive with better drive
#
replace_workflow_upgrade() {
    local target_position="$1"
    
    echo "üìà DRIVE UPGRADE WORKFLOW"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "This process will help you upgrade a working drive to a larger or"
    echo "better drive with direct data copy."
    echo ""
    
    # Check if we need to prompt for source drive selection
    if [[ -z "$target_position" ]]; then
        echo "üîç SOURCE DRIVE SELECTION"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        echo "First, let's identify which drive you want to upgrade."
        echo ""
        
        target_position=$(replace_prompt_source_drive_selection)
        if [[ $? -ne 0 || -z "$target_position" ]]; then
            echo "‚ùå No source drive selected"
            return 1
        fi
        
        echo "‚úÖ Selected source drive at position $target_position"
        echo ""
    fi
    
    # Pre-workflow step: Get target drive information before starting workflow
    echo "üîç STEP 0: Upgrade Planning"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "Before we begin, let's identify both the source and target drives."
    echo ""
    
    # Get source drive info first
    local source_device
    
    # Use the same logic as health command to map position to device
    # This maps position to the actual device path
    local health_result
    health_result=$(cd /media/tRAID/local/src/pooltool && ./pooltool.sh health "$target_position" 2>/dev/null | grep "Device:" | awk '{print $2}')
    source_device="$health_result"
    
    if [[ -z "$source_device" || ! -b "$source_device" ]]; then
        echo "‚ùå Cannot find source drive at position $target_position"
        echo "üí° Please check that position $target_position exists and is accessible"
        return 1
    fi
    
    local source_size_human=$(lsblk -no SIZE "$source_device" | head -1 | xargs)
    local source_size_bytes=$(lsblk -bno SIZE "$source_device" | head -1 | xargs)
    local source_model=$(lsblk -no MODEL "$source_device" | head -1 | xargs)
    
    echo "üìã Source Drive (Position $target_position):"
    echo "   Device: $source_device"
    echo "   Size: ${source_size_human:-"Unknown"}"
    echo "   Model: ${source_model:-"Unknown"}"
    echo ""
    
    # Now get target drive selection
    echo "üíΩ Available drives for upgrade:"
    echo ""
    
    # Show available drives (excluding current SnapRAID drives)
    local snapraid_volumes=( $(snapraid::devices volumes) )
    local available_drives=()
    
    # Get all block devices
    while IFS= read -r drive; do
        # Skip if it's already in SnapRAID array
        local skip=false
        for snapraid_volume in "${snapraid_volumes[@]}"; do
            if [[ "$drive" == "$snapraid_volume" ]]; then
                skip=true
                break
            fi
        done
        
        if [[ "$skip" == false && "$drive" != "$source_device" ]]; then
            available_drives+=("$drive")
        fi
    done < <(lsblk -plno NAME,TYPE | awk '$2=="disk" {print $1}')
    
    if [[ ${#available_drives[@]} -eq 0 ]]; then
        echo "‚ùå No available drives found for upgrade"
        echo "üí° Please connect your new drive and try again"
        return 1
    fi
    
    # Show available drives with sizes and better formatting
    echo "Available drives for upgrade:"
    echo ""
    printf "  %-4s %-12s %-10s %-25s %-15s %s\n" "NUM" "DEVICE" "SIZE" "MODEL" "STATUS" "RECOMMENDATION"
    printf "  %-4s %-12s %-10s %-25s %-15s %s\n" "---" "------------" "----------" "-------------------------" "---------------" "--------------"
    
    local drive_index=1
    local recommended_drive=""
    local largest_size=0
    
    for drive in "${available_drives[@]}"; do
        local size_human=$(lsblk -no SIZE "$drive" | head -1 | xargs)
        local size_bytes=$(lsblk -bno SIZE "$drive" | head -1 | xargs)
        local model=$(lsblk -no MODEL "$drive" | head -1 | xargs)
        
        # Check if drive is large enough
        local size_status="‚úÖ Compatible"
        local recommendation=""
        if [[ $size_bytes -lt $source_size_bytes ]]; then
            size_status="‚ùå Too Small"
            recommendation="Not suitable"
        else
            # Find the largest compatible drive for recommendation
            if [[ $size_bytes -gt $largest_size ]]; then
                largest_size=$size_bytes
                recommended_drive="$drive"
                recommendation="‚≠ê Recommended"
            else
                recommendation="Good option"
            fi
        fi
        
        printf "  %-4s %-12s %-10s %-25s %-15s %s\n" "$drive_index" "$drive" "$size_human" "${model:-"Unknown"}" "$size_status" "$recommendation"
        ((drive_index++))
    done
    
    echo ""
    echo "üí° Options:"
    echo "   ‚Ä¢ Enter a device path (e.g., /dev/sdw)"
    echo "   ‚Ä¢ Enter a number from the list above"
    echo "   ‚Ä¢ Type 'visual' to use the visual drive selector"
    echo "   ‚Ä¢ Type 'q' to quit"
    echo ""
    
    # Provide default recommendation
    if [[ -n "$recommended_drive" ]]; then
        echo "üéØ Recommended: $recommended_drive (largest compatible drive)"
    fi
    
    # Get new drive selection with better validation and options
    local target_device=""
    while [[ -z "$target_device" ]]; do
        local default_prompt=""
        if [[ -n "$recommended_drive" ]]; then
            default_prompt=" [default: $recommended_drive]"
        fi
        
        read -p "Select target drive${default_prompt}: " user_input
        
        # Handle empty input (use default)
        if [[ -z "$user_input" && -n "$recommended_drive" ]]; then
            user_input="$recommended_drive"
        fi
        
        if [[ "$user_input" == "q" || "$user_input" == "quit" ]]; then
            echo "‚ùå Upgrade cancelled by user"
            return 1
        fi
        
        # Handle visual selector
        if [[ "$user_input" == "visual" ]]; then
            echo "üéØ Opening visual drive selector..."
            echo "üí° Select your target drive from the visual layout"
            echo ""
            
            # Call the visual drive selector and capture only the final result line
            local visual_output
            visual_output=$(pooltool::commands::drives select)
            local selector_exit_code=$?
            
            if [[ $selector_exit_code -eq 0 && -n "$visual_output" ]]; then
                # Extract only the last line (the actual result)
                local visual_selection
                visual_selection=$(echo "$visual_output" | tail -n 1)
                
                echo ""
                echo "‚úÖ Drive selected from visual interface"
                
                # Handle different output formats from visual selector
                if [[ "$visual_selection" =~ ^UNALLOCATED: ]]; then
                    echo "üí° Selected unallocated drive: $visual_selection"
                    echo "üîÑ This drive will need to be allocated during the workflow"
                    user_input="$visual_selection"
                else
                    echo "‚úÖ Using selected device: $visual_selection"
                    user_input="$visual_selection"
                fi
            else
                echo "‚ùå Visual selection cancelled or failed"
                continue
            fi
        fi
        
        # Handle numeric selection
        if [[ "$user_input" =~ ^[0-9]+$ ]]; then
            local selected_index=$user_input
            if [[ $selected_index -ge 1 && $selected_index -le ${#available_drives[@]} ]]; then
                user_input="${available_drives[$((selected_index-1))]}"
            else
                echo "‚ùå Invalid selection. Please choose a number between 1 and ${#available_drives[@]}"
                continue
            fi
        fi
        
        # Handle unallocated drive selection from visual selector
        if [[ "$user_input" =~ ^UNALLOCATED: ]]; then
            echo "üí° Processing unallocated drive selection: $user_input"
            echo ""
            
            # Enhanced parsing for different UNALLOCATED formats:
            # Format 1: UNALLOCATED:NAME:POSITION (from simple visual selector)
            # Format 2: UNALLOCATED:NAME:POSITION:CONNECTOR:DEVICE_SLOT (from detailed arcconf detection)
            local drive_name drive_position drive_connector drive_device_slot
            
            if [[ "$user_input" =~ ^UNALLOCATED:([^:]+):([0-9]+):([0-9]+):([0-9]+)$ ]]; then
                # Format 2: Detailed format with connector/device_slot
                drive_name="${BASH_REMATCH[1]}"
                drive_position="${BASH_REMATCH[2]}"
                drive_connector="${BASH_REMATCH[3]}"
                drive_device_slot="${BASH_REMATCH[4]}"
                echo "üîç Detailed unallocated drive info detected"
            elif [[ "$user_input" =~ ^UNALLOCATED:([^:]+):([0-9]+)$ ]]; then
                # Format 1: Simple format, need to calculate connector/device_slot
                drive_name="${BASH_REMATCH[1]}"
                drive_position="${BASH_REMATCH[2]}"
                # Calculate connector and device_slot from position
                drive_connector=$(( (drive_position - 1) / 4 ))
                drive_device_slot=$(( 3 - ((drive_position - 1) % 4) ))
                echo "üîç Simple unallocated drive format, calculated position"
            else
                echo "‚ùå Invalid unallocated drive format: $user_input"
                continue
            fi
            
            echo "   Drive: $drive_name at position $drive_position"
            echo "   Physical: Connector $drive_connector, Device $drive_device_slot"
            echo ""
            
            # Find the system device path for this unallocated drive
            echo "üîç Finding system device path for unallocated drive..."
            
            # Load driveutils module to access unified mapping
            bootstrap_load_module pooltool/driveutils >/dev/null 2>&1
            
            # Get unified mapping data 
            local unified_data
            if ! unified_data=$(pooltool::create_unified_mapping 1 2>/dev/null); then
                echo "‚ùå Failed to get drive mapping data"
                echo "ÔøΩ Cannot determine device path for unallocated drive"
                continue
            fi
            
            # Look for unallocated drive in unified mapping by connector/device_slot
            local found_device_path=""
            local found_wwn=""
            local found_serial=""
            local found_model=""
            
            while IFS= read -r record; do
                if [[ -n "$record" ]]; then
                    # Parse unified record format: mount_name:arcconf_id:connector:device_slot:snapraid_name:device_path:wwn:serial:channel:device_num:model:size:status
                    if [[ "$record" =~ ^([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
                        local rec_connector="${BASH_REMATCH[3]}"
                        local rec_device_slot="${BASH_REMATCH[4]}"
                        local rec_device_path="${BASH_REMATCH[6]}"
                        local rec_wwn="${BASH_REMATCH[7]}"
                        local rec_serial="${BASH_REMATCH[8]}"
                        local rec_model="${BASH_REMATCH[11]}"
                        local rec_status="${BASH_REMATCH[13]}"
                        
                        # Check if this matches our target connector/device_slot
                        if [[ "$rec_connector" == "$drive_connector" && "$rec_device_slot" == "$drive_device_slot" ]]; then
                            # Found the drive record!
                            found_wwn="$rec_wwn"
                            found_serial="$rec_serial"
                            found_model="$rec_model"
                            
                            if [[ -n "$rec_device_path" && "$rec_device_path" != "NONE" ]]; then
                                # This drive already has a device path (shouldn't happen for unallocated)
                                found_device_path="$rec_device_path"
                                echo "‚ö†Ô∏è  Drive appears to already be allocated: $rec_device_path"
                            else
                                echo "‚úÖ Found unallocated drive record"
                                echo "   WWN: ${found_wwn:-Unknown}"
                                echo "   Serial: ${found_serial:-Unknown}"
                                echo "   Model: ${found_model:-Unknown}"
                            fi
                            break
                        fi
                    fi
                fi
            done <<< "$unified_data"
            
            # If we found WWN or serial, try to find the actual device path
            if [[ -z "$found_device_path" && ( -n "$found_wwn" || -n "$found_serial" ) ]]; then
                echo ""
                echo "üîç Searching for system device path..."
                
                # Search all /dev/sd* devices for matching WWN or serial
                for device in /dev/sd*; do
                    # Skip partition numbers (only check whole devices)
                    if [[ "$device" =~ [0-9]$ ]]; then
                        continue
                    fi
                    
                    if [[ -b "$device" ]]; then
                        # Get device WWN and serial
                        local dev_wwn dev_serial
                        dev_wwn=$(lsblk -n -o WWN "$device" 2>/dev/null | head -1 | tr -d ' ' || echo "")
                        dev_serial=$(lsblk -n -o SERIAL "$device" 2>/dev/null | head -1 | tr -d ' ' || echo "")
                        
                        # Normalize WWN format for comparison
                        if [[ "$dev_wwn" =~ ^0x([A-F0-9]+)$ ]]; then
                            dev_wwn="${BASH_REMATCH[1]^^}"  # Remove 0x and convert to uppercase
                        elif [[ -n "$dev_wwn" ]]; then
                            dev_wwn="${dev_wwn^^}"  # Convert to uppercase
                        fi
                        
                        # Check if WWN matches
                        if [[ -n "$found_wwn" && -n "$dev_wwn" && "$found_wwn" == "$dev_wwn" ]]; then
                            found_device_path="$device"
                            echo "‚úÖ Found device by WWN match: $device"
                            break
                        # Check if serial matches  
                        elif [[ -n "$found_serial" && -n "$dev_serial" && "$found_serial" == "$dev_serial" ]]; then
                            found_device_path="$device"
                            echo "‚úÖ Found device by serial match: $device"
                            break
                        fi
                    fi
                done
            fi
            
            if [[ -z "$found_device_path" ]]; then
                echo "‚ùå Could not find system device path for unallocated drive"
                echo "üí° The drive may need to be physically connected or initialized"
                echo "üí° Please check hardware connections and try again"
                continue
            fi
            
            echo "üéØ Unallocated drive successfully mapped!"
            echo "   Position: $drive_position ($drive_name)"
            echo "   Device: $found_device_path"
            echo "   Model: ${found_model:-Unknown}"
            echo ""
            echo "üí° This drive will be treated as a regular target device"
            echo "‚ö†Ô∏è  Note: Drive may need SnapRAID configuration after the upgrade"
            echo ""
            
            # Use the found device path as the regular user input
            user_input="$found_device_path"
            echo "üîÑ Continuing with device: $user_input"
        fi
        
        # Validate input (for regular device paths)
        if [[ ! -b "$user_input" ]]; then
            echo "‚ùå $user_input is not a valid block device"
            continue
        fi
        
        # Check if it's in available drives
        local found=false
        for drive in "${available_drives[@]}"; do
            if [[ "$drive" == "$user_input" ]]; then
                found=true
                break
            fi
        done
        
        if [[ "$found" == false ]]; then
            echo "‚ùå Drive $user_input is not available for upgrade (may be in use)"
            continue
        fi
        
        # Check size compatibility
        local new_size=$(lsblk -bno SIZE "$user_input" | head -1)
        if [[ $new_size -lt $source_size_bytes ]]; then
            echo "‚ùå Target drive is smaller than source drive"
            echo "   Source: $source_size_human"
            echo "   Target: $(lsblk -no SIZE "$user_input" | head -1)"
            echo ""
            read -p "Continue anyway? (NOT RECOMMENDED) [y/N] (default: N): " confirm
            if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
                continue
            fi
        fi
        
        target_device="$user_input"
    done
    
    # Show upgrade summary and get final confirmation
    echo ""
    echo "üìã UPGRADE SUMMARY"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "Source Drive: $source_device ($source_size_human) - Position $target_position"
    echo "Target Drive: $target_device ($(lsblk -no SIZE "$target_device" | head -1 | xargs))"
    echo ""
    echo "This will:"
    echo "1. Safely copy all data from source to target drive"
    echo "2. Update SnapRAID configuration"
    echo "3. Replace the source drive in the array"
    echo "4. Keep the source drive as backup"
    echo ""
    
    read -p "Ready to start the upgrade workflow? [y/N] (default: N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "‚ùå Upgrade cancelled by user"
        return 1
    fi
    
    # Store the target device globally for the workflow
    REPLACE_NEW_DEVICE="$target_device"
    REPLACE_TARGET_DEVICE="$source_device"
    REPLACE_TARGET_POSITION="$target_position"
    
    echo ""
    echo "üöÄ Starting upgrade workflow..."
    echo ""
    
    # Start workflow with 7 steps for upgrade
    local workflow_id
    workflow_id=$(workflow_start "drive_upgrade" 7)
    if [[ $? -ne 0 ]]; then
        echo "‚ùå Failed to initialize workflow system"
        return 1
    fi
    
    # Set global workflow ID for subsequent workflow functions
    WORKFLOW_CURRENT_ID="$workflow_id"
    
    echo "üìã Upgrade Workflow ID: $workflow_id"
    echo ""
    
    # Step 1: Source Drive Assessment
    workflow_step 1 "Source Drive Assessment" "running"
    if ! replace_upgrade_step_source_assessment "$target_position"; then
        workflow_step 1 "Source Drive Assessment" "failed"
        workflow_complete "aborted" "Source drive assessment failed"
        return 1
    fi
    workflow_step 1 "Source Drive Assessment" "complete"
    
    # Step 2: New Drive Preparation
    workflow_step 2 "New Drive Preparation" "running"
    if ! replace_upgrade_step_new_drive_prep; then
        workflow_step 2 "New Drive Preparation" "failed"
        workflow_complete "aborted" "New drive preparation failed"
        return 1
    fi
    workflow_step 2 "New Drive Preparation" "complete"
    
    # Step 3: Capacity and Compatibility Check
    workflow_step 3 "Capacity and Compatibility Check" "running"
    if ! replace_upgrade_step_compatibility_check; then
        workflow_step 3 "Capacity and Compatibility Check" "failed"
        workflow_complete "aborted" "Compatibility check failed"
        return 1
    fi
    workflow_step 3 "Capacity and Compatibility Check" "complete"
    
    # Step 4: Safety Checks
    workflow_step 4 "Safety Checks" "running"
    if ! replace_step_safety "$REPLACE_TARGET_POSITION"; then
        workflow_step 4 "Safety Checks" "failed"
        workflow_complete "failed" "Safety checks failed"
        return 1
    fi
    workflow_step 4 "Safety Checks" "complete"
    
    # Step 5: Data Copy Process
    workflow_step 5 "Data Copy Process" "running"
    if ! replace_upgrade_step_data_copy; then
        workflow_step 5 "Data Copy Process" "failed"
        workflow_complete "failed" "Data copy failed"
        return 1
    fi
    workflow_step 5 "Data Copy Process" "complete"
    
    # Step 6: Drive Swap
    workflow_step 6 "Drive Swap" "running"
    if ! replace_upgrade_step_drive_swap; then
        workflow_step 6 "Drive Swap" "failed"
        workflow_complete "failed" "Drive swap failed"
        return 1
    fi
    workflow_step 6 "Drive Swap" "complete"
    
    # Step 7: Final Validation
    workflow_step 7 "Final Validation" "running"
    if ! replace_step_validation "$REPLACE_TARGET_POSITION"; then
        workflow_step 7 "Final Validation" "failed"
        workflow_complete "failed" "Validation failed"
        return 1
    fi
    workflow_step 7 "Final Validation" "complete"
    
    workflow_complete "success" "Drive upgrade completed successfully"
    
    echo ""
    echo "üéâ DRIVE UPGRADE COMPLETED SUCCESSFULLY!"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Your drive has been successfully upgraded with larger capacity!"
    
    return 0
}

#
# Recovery workflow: Replace failed drive using SnapRAID parity
#
replace_workflow_recovery() {
    local target_position="$1"
    
    echo "üö® FAILED DRIVE RECOVERY WORKFLOW"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "This process will help you replace a failed drive and recover data"
    echo "from SnapRAID parity information."
    echo ""
    
    # Start workflow with 6 steps for recovery
    local workflow_id
    workflow_id=$(workflow_start "drive_recovery" 6)
    if [[ $? -ne 0 ]]; then
        echo "‚ùå Failed to initialize workflow system"
        return 1
    fi
    
    # Set global workflow ID for subsequent workflow functions
    WORKFLOW_CURRENT_ID="$workflow_id"
    
    echo "üìã Recovery Workflow ID: $workflow_id"
    echo ""
    
    # Step 1: Failed Drive Assessment
    workflow_step 1 "Failed Drive Assessment" "running"
    if ! replace_recovery_step_failed_assessment "$target_position"; then
        workflow_step 1 "Failed Drive Assessment" "failed"
        workflow_complete "aborted" "Failed drive assessment cancelled"
        return 1
    fi
    workflow_step 1 "Failed Drive Assessment" "complete"
    
    # Step 2: SnapRAID Parity Check
    workflow_step 2 "SnapRAID Parity Check" "running"
    if ! replace_recovery_step_parity_check; then
        workflow_step 2 "SnapRAID Parity Check" "failed"
        workflow_complete "failed" "Parity check failed - recovery not safe"
        return 1
    fi
    workflow_step 2 "SnapRAID Parity Check" "complete"
    
    # Continue with standard steps...
    # Implementation continues with recovery-specific steps
    
    echo "üö® RECOVERY WORKFLOW IN DEVELOPMENT"
    echo "This workflow will be fully implemented in the next iteration."
    echo "For now, please use manual SnapRAID recovery procedures."
    
    return 0
}

#
# Add drive workflow: Add new drive to array
#
replace_workflow_add_drive() {
    local target_position="$1"
    
    echo "‚ûï ADD NEW DRIVE WORKFLOW"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "This process will help you add a brand new drive to your storage array."
    echo ""
    
    # This workflow can leverage much of the existing disk command logic
    echo "üí° NEW DRIVE ADDITION IN DEVELOPMENT"
    echo "This workflow will integrate with the existing 'disk' command functionality."
    echo "For now, you can use: pooltool disk"
    
    return 0
}

#
# Step 1: Drive Assessment - Select and analyze target drive using SnapRAID integration
# $1: optional drive position
#
replace_step_assessment() {
    local target_position="$1"
    
    echo "üîç Step 1: Drive Assessment"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Get SnapRAID drive information
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_partitions=( $(snapraid::devices partitions) )
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    
    # Show current drive layout
    echo "Current Drive Layout:"
    
    # Use a simpler, non-blocking drive overview for the wizard
    echo "üìã Quick Drive Overview:"
    echo "   Checking SnapRAID configuration..."
    
    # Get SnapRAID drive count without expensive operations
    local snapraid_names=( $(snapraid::devices names 2>/dev/null || echo) )
    local drive_count=${#snapraid_names[@]}
    
    if [[ $drive_count -gt 0 ]]; then
        echo "   ‚úÖ SnapRAID array detected with $drive_count drives"
        echo "   üìç For detailed drive layout, run: pooltool drivemap"
    else
        echo "   ‚ö†Ô∏è  No SnapRAID configuration detected"
    fi
    
    echo ""
    echo "SnapRAID Array Drives:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Show detailed SnapRAID drive information
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        local drive_name="${snapraid_names[i]}"
        local partition="${snapraid_partitions[i]}"
        local mountpoint="${snapraid_mountpoints[i]}"
        
        # Get capacity info
        local capacity_info=""
        if [[ -n "$partition" ]]; then
            capacity_info=$(df -h "$partition" 2>/dev/null | tail -1 | awk '{print $3"/"$2" ("$5" used)"}')
        fi
        
        printf "%-8s %-15s %-25s %s\n" "$drive_name" "$partition" "$mountpoint" "$capacity_info"
    done
    
    echo ""
    
    # Get target drive selection if not provided
    if [[ -z "$target_position" ]]; then
        echo "üìã Drive Selection Options:"
        echo "1. Select by position number (1-24) from drive map above"
        echo "2. Select from SnapRAID drive list"
        echo ""
        
        local selection_method
        selection_method=$(bashful input -p "Choose selection method (1 or 2): " -d "1")
        
        case "$selection_method" in
            "1")
                # Position-based selection (existing logic)
                while true; do
                    local user_input
                    user_input=$(bashful input -p "Enter the position number (1-24) of the drive to replace: " -d "")
                    
                    if [[ "$user_input" == "q" || "$user_input" == "quit" ]]; then
                        echo "‚ùå Drive replacement cancelled by user"
                        return 1
                    elif [[ "$user_input" =~ ^[0-9]+$ ]] && [[ $user_input -ge 1 ]] && [[ $user_input -le 24 ]]; then
                        target_position="$user_input"
                        break
                    else
                        echo "‚ùå Invalid position. Please enter a number between 1 and 24, or 'q' to quit."
                    fi
                done
                ;;
            "2")
                # SnapRAID drive selection (enhanced from disk command)
                local chosen_drive
                chosen_drive=$(replace_choose_snapraid_drive)
                if [[ $? -ne 0 ]]; then
                    echo "‚ùå Drive selection cancelled"
                    return 1
                fi
                
                # Convert SnapRAID drive name to position
                target_position=$(replace_snapraid_name_to_position "$chosen_drive")
                if [[ -z "$target_position" ]]; then
                    echo "‚ùå Could not determine position for drive $chosen_drive"
                    return 1
                fi
                ;;
            "q"|"quit")
                echo "‚ùå Drive replacement cancelled by user"
                return 1
                ;;
            *)
                echo "‚ùå Invalid selection method"
                return 1
                ;;
        esac
    fi
    
    # Validate drive exists at position (existing validation logic)
    local drive_info
    if ! drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "‚ùå No drive found at position $target_position"
        return 1
    fi
    
    # Parse drive information
    local drive_name device_path model
    read -r drive_name device_path model <<< "$drive_info"
    
    echo "üìä Drive Analysis for Position $target_position:"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    
    # Show detailed drive information
    replace_show_drive_details "$target_position" "$drive_name" "$device_path" "$model"
    
    # Show SnapRAID integration details
    replace_show_snapraid_integration "$drive_name"
    
    echo ""
    echo "‚ö†Ô∏è  IMPORTANT CONSIDERATIONS:"
    echo "‚Ä¢ Replacing this drive will require data migration or rebuild"
    echo "‚Ä¢ Ensure you have recent backups before proceeding"
    echo "‚Ä¢ The process may take several hours depending on data size"
    echo "‚Ä¢ System will remain operational during most of the process"
    
    echo ""
    if ! pooltool::question -p "Do you want to proceed with replacing drive at position $target_position?" -d "n"; then
        echo "‚ùå Drive replacement cancelled by user"
        return 1
    fi
    
    # Store target information globally for other steps
    REPLACE_TARGET_POSITION="$target_position"
    REPLACE_TARGET_DRIVE="$drive_name"
    REPLACE_TARGET_DEVICE="$device_path"
    REPLACE_TARGET_MODEL="$model"
    
    echo "‚úÖ Drive assessment completed - Position $target_position confirmed"
    return 0
}

#
# Enhanced SnapRAID drive selection (based on disk command logic)
#
replace_choose_snapraid_drive() {
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_partitions=( $(snapraid::devices partitions) )
    local show_detail=false
    
    while true; do
        local chosen=""
        
        if [[ "$show_detail" == false ]]; then
            chosen="$(bashful choice -p "Which drive would you like to replace?" "${snapraid_names[@]}" "More info..." "Cancel")"
        else
            local detailed_choices=()
            for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
                local choice="${snapraid_names[i]}"
                if [[ -n "${snapraid_partitions[i]}" ]]; then
                    choice+="$(df -H --output="avail,size" "${snapraid_partitions[i]}" 2>/dev/null | tail -n 1 | awk '{ print " ("$1,"available of",$2")" }')"
                fi
                detailed_choices+=( "$choice" )
            done
            chosen="$(bashful choice -p "Which drive would you like to replace?" "${detailed_choices[@]}" "Cancel")"
        fi
        
        if [[ "$chosen" == "More info..." ]]; then
            show_detail=true
            continue
        elif [[ "$chosen" == "Cancel" ]]; then
            return 1
        fi
        
        # Extract drive name (remove capacity info if present)
        chosen="${chosen%% *}"
        echo "$chosen"
        return 0
    done
}

#
# Convert SnapRAID drive name to position number
#
replace_snapraid_name_to_position() {
    local snapraid_drive="$1"
    
    # This would need to be implemented based on the mapping between
    # SnapRAID drive names and physical positions
    # For now, return empty to indicate we need the position-based method
    echo ""
}

#
# Show SnapRAID integration details for a drive
#
replace_show_snapraid_integration() {
    local drive_name="$1"
    
    echo ""
    echo "üóÑÔ∏è  SnapRAID Integration:"
    
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_partitions=( $(snapraid::devices partitions) )
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    
    # Find drive in SnapRAID arrays
    local found=false
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$drive_name" ]]; then
            echo "   Role: ${snapraid_names[i]}"
            echo "   Partition: ${snapraid_partitions[i]}"
            echo "   Mount Point: ${snapraid_mountpoints[i]}"
            
            # Check if it's a parity drive
            if [[ "$drive_name" =~ PPU[0-9]+ ]]; then
                echo "   ‚ö†Ô∏è  WARNING: This is a PARITY drive - replacement requires special care"
            else
                echo "   Type: Data drive"
            fi
            
            found=true
            break
        fi
    done
    
    if [[ "$found" == false ]]; then
        echo "   ‚ö†Ô∏è  Drive not found in current SnapRAID configuration"
        echo "   üí° This may be a new drive or not yet configured"
    fi
}

#
# Step 2: Safety Checks - Run comprehensive safety validation
# $1: target position
#
replace_step_safety() {
    local target_position="$1"
    
    echo ""
    echo "üõ°Ô∏è  Step 2: Safety Checks"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Run pre-flight safety checks
    if ! safety_preflight_check "replace_drive" "$target_position"; then
        local safety_result=$?
        
        echo ""
        case $safety_result in
            $SAFETY_CHECK_WARN)
                echo "‚ö†Ô∏è  Safety warnings detected. Review the issues above."
                if ! pooltool::question -p "Do you want to continue despite warnings?" -d "n"; then
                    echo "‚ùå Drive replacement cancelled due to safety concerns"
                    return 1
                fi
                ;;
            $SAFETY_CHECK_FAIL)
                echo "‚ùå Safety checks failed. Please resolve the issues before proceeding."
                if ! pooltool::question -p "Force continue anyway? (NOT RECOMMENDED)" -d "n"; then
                    echo "‚ùå Drive replacement cancelled due to safety failures"
                    return 1
                fi
                ;;
            $SAFETY_CHECK_CRITICAL)
                echo "üö® Critical safety issues detected. Operation cannot proceed safely."
                echo "‚ùå Drive replacement cancelled due to critical safety issues"
                return 1
                ;;
        esac
    fi
    
    echo ""
    # Safety confirmation with risk assessment
    local risk_details="Drive: $REPLACE_TARGET_DRIVE at position $target_position
Model: $REPLACE_TARGET_MODEL
This operation will involve:
‚Ä¢ Physical drive removal and installation
‚Ä¢ Data migration or parity rebuild
‚Ä¢ Temporary system exposure during replacement"
    
    if ! safety_confirm_operation "Drive Replacement" "medium" "$risk_details"; then
        return 1
    fi
    
    echo "‚úÖ Safety checks completed and confirmed"
    return 0
}

#
# Step 3: Preparation - Prepare system for drive replacement
# $1: target position
#
replace_step_preparation() {
    local target_position="$1"
    
    echo ""
    echo "üõ†Ô∏è  Step 3: Preparation"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Check if drive is mounted and offer to unmount
    echo "üîç Checking mount status..."
    if mount | grep -q "$REPLACE_TARGET_DEVICE"; then
        echo "‚ö†Ô∏è  Drive $REPLACE_TARGET_DRIVE is currently mounted"
        
        if pooltool::question -p "Unmount the drive now?" -d "y"; then
            echo "üì§ Unmounting $REPLACE_TARGET_DRIVE..."
            if sudo umount "$REPLACE_TARGET_DEVICE" 2>/dev/null; then
                echo "‚úÖ Drive unmounted successfully"
            else
                echo "‚ùå Failed to unmount drive. You may need to stop services using it."
                if ! pooltool::question -p "Continue anyway?" -d "n"; then
                    return 1
                fi
            fi
        fi
    else
        echo "‚úÖ Drive is not currently mounted"
    fi
    
    # Offer to blink the drive LED for identification
    echo ""
    echo "üí° Physical Drive Identification"
    if pooltool::question -p "Blink the LED on the target drive for identification?" -d "y"; then
        echo "üîÜ Blinking LED on drive $REPLACE_TARGET_DRIVE..."
        blink_drive_led "$target_position" 30 || {
            echo "‚ö†Ô∏è  LED blink command failed, but continuing with replacement"
        }
        
        echo "üí° The LED should be blinking on the drive to be replaced."
        echo "   Look for the blinking light in your drive bay."
        
        if ! pooltool::question -p "Can you see the blinking LED and identify the drive?" -d "y"; then
            echo "‚ùå Cannot proceed without physical drive identification"
            return 1
        fi
    fi
    
    # Create backup of critical information
    echo ""
    echo "üíæ Creating replacement information backup..."
    local backup_file="/tmp/drive_replacement_${target_position}_$(date +%Y%m%d_%H%M%S).info"
    {
        echo "# Drive Replacement Information"
        echo "# Generated: $(date)"
        echo "Target Position: $target_position"
        echo "Drive Name: $REPLACE_TARGET_DRIVE"
        echo "Device Path: $REPLACE_TARGET_DEVICE"
        echo "Model: $REPLACE_TARGET_MODEL"
        echo ""
        echo "# Drive Information Before Replacement:"
        get_drive_info_by_position "$target_position" 2>/dev/null || echo "Drive info unavailable"
        echo ""
        echo "# Health Information:"
        pooltool health "$target_position" 2>/dev/null || echo "Health info unavailable"
    } > "$backup_file"
    
    echo "üìã Replacement information saved to: $backup_file"
    
    echo ""
    echo "‚úÖ Preparation completed successfully"
    echo "üìù Ready for physical drive replacement"
    
    return 0
}

#
# Step 4: Physical Replacement - Guide through physical drive replacement
# $1: target position
#
replace_step_physical() {
    local target_position="$1"
    
    echo ""
    echo "üîß Step 4: Physical Drive Replacement"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    echo "üìã Physical Replacement Instructions:"
    echo ""
    echo "1Ô∏è‚É£  BEFORE REMOVING THE OLD DRIVE:"
    echo "   ‚Ä¢ Ensure the LED is blinking (if enabled in previous step)"
    echo "   ‚Ä¢ Note the position - this is bay position $target_position"
    echo "   ‚Ä¢ Have your replacement drive ready"
    echo ""
    echo "2Ô∏è‚É£  REMOVING THE OLD DRIVE:"
    echo "   ‚Ä¢ Power down the drive bay if hot-swap is not supported"
    echo "   ‚Ä¢ Carefully disconnect SATA power and data cables"
    echo "   ‚Ä¢ Remove the drive from the bay"
    echo "   ‚Ä¢ Keep the old drive safe in case data recovery is needed"
    echo ""
    echo "3Ô∏è‚É£  INSTALLING THE NEW DRIVE:"
    echo "   ‚Ä¢ Insert the new drive into the same bay (position $target_position)"
    echo "   ‚Ä¢ Connect SATA power and data cables securely"
    echo "   ‚Ä¢ Ensure the drive is properly seated and secured"
    echo "   ‚Ä¢ Power on the drive bay if it was powered down"
    echo ""
    
    if ! pooltool::question -p "Have you completed the physical drive replacement?" -d "n"; then
        echo "‚ùå Physical replacement not completed - workflow paused"
        echo "üí° You can resume this workflow later by running:"
        echo "   pooltool replace-drive $target_position --resume"
        return 1
    fi
    
    # Wait for system to detect new drive
    echo ""
    echo "‚è≥ Waiting for system to detect the new drive..."
    sleep 5
    
    # Verify new drive is detected
    echo "üîç Verifying new drive detection..."
    local detection_attempts=0
    local max_attempts=12  # 60 seconds total
    
    while [[ $detection_attempts -lt $max_attempts ]]; do
        if arcconf getconfig 1 >/dev/null 2>&1; then
            echo "‚úÖ RAID controller responding"
            break
        fi
        
        echo "‚è≥ Waiting for RAID controller... (attempt $((detection_attempts + 1))/$max_attempts)"
        sleep 5
        ((detection_attempts++))
    done
    
    if [[ $detection_attempts -eq $max_attempts ]]; then
        echo "‚ùå RAID controller not responding after drive replacement"
        echo "üí° This may be normal - the controller might need more time"
        
        if ! pooltool::question -p "Continue anyway? The new drive might not be immediately visible" -d "y"; then
            return 1
        fi
    fi
    
    echo "‚úÖ Physical replacement completed"
    echo "üìù Proceeding to data migration phase"
    
    return 0
}

#
# Step 5: Data Migration - Handle data migration or rebuild
# $1: target position
#
replace_step_migration() {
    local target_position="$1"
    
    echo ""
    echo "üì¶ Step 5: Data Migration"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    echo "üîç Analyzing data migration options..."
    
    # Check if new drive is detected
    local new_drive_info
    if new_drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        local new_drive_name new_device_path new_model
        read -r new_drive_name new_device_path new_model <<< "$new_drive_info"
        
        echo "‚úÖ New drive detected:"
        echo "   Drive: $new_drive_name"
        echo "   Device: $new_device_path" 
        echo "   Model: $new_model"
    else
        echo "‚ö†Ô∏è  New drive not yet detected by the system"
        echo "üí° This may be normal immediately after replacement"
        
        if pooltool::question -p "Wait longer for drive detection?" -d "y"; then
            echo "‚è≥ Waiting additional time for drive detection..."
            sleep 15
            
            if new_drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
                local new_drive_name new_device_path new_model
                read -r new_drive_name new_device_path new_model <<< "$new_drive_info"
                echo "‚úÖ New drive now detected: $new_drive_name"
            else
                echo "‚ùå New drive still not detected"
                echo "üí° You may need to:"
                echo "   ‚Ä¢ Check physical connections"
                echo "   ‚Ä¢ Restart the system"
                echo "   ‚Ä¢ Check RAID controller status"
                
                if ! pooltool::question -p "Continue with manual migration setup?" -d "n"; then
                    return 1
                fi
            fi
        fi
    fi
    
    echo ""
    echo "üìã Data Migration Options:"
    echo ""
    echo "1Ô∏è‚É£  SnapRAID Parity Rebuild (Recommended)"
    echo "   ‚Ä¢ Automatically rebuild data from parity information"
    echo "   ‚Ä¢ Safe and reliable for SnapRAID arrays"
    echo "   ‚Ä¢ Requires array to be in sync"
    echo ""
    echo "2Ô∏è‚É£  Manual Data Copy"
    echo "   ‚Ä¢ Copy data from backup or another source"
    echo "   ‚Ä¢ Full control over the process"
    echo "   ‚Ä¢ Requires manual setup and monitoring"
    echo ""
    echo "3Ô∏è‚É£  Skip Migration (New Empty Drive)"
    echo "   ‚Ä¢ Leave drive empty for new data"
    echo "   ‚Ä¢ Suitable for expansion or dedicated use"
    echo "   ‚Ä¢ No data recovery"
    echo ""
    
    local migration_choice
    migration_choice=$(bashful input -p "Choose migration method (1-3): " -d "1")
    
    case "$migration_choice" in
        "1")
            echo "üîÑ Initiating SnapRAID parity rebuild..."
            replace_migration_snapraid_rebuild "$target_position"
            ;;
        "2")
            echo "üìã Setting up manual data copy..."
            replace_migration_manual_copy "$target_position"
            ;;
        "3")
            echo "üìÅ Configuring empty drive for new use..."
            replace_migration_new_empty "$target_position"
            ;;
        *)
            echo "‚ùå Invalid choice - defaulting to parity rebuild"
            replace_migration_snapraid_rebuild "$target_position"
            ;;
    esac
    
    echo "‚úÖ Data migration phase completed"
    return 0
}

#
# Step 6: Validation - Final validation and integration
# $1: target position
#
replace_step_validation() {
    local target_position="$1"
    
    echo ""
    echo "‚úÖ Step 6: Final Validation"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    echo "üîç Running post-replacement validation..."
    
    # Validate new drive health
    echo ""
    echo "üè• Health Validation:"
    if pooltool health "$target_position" --quiet; then
        echo "‚úÖ New drive health check passed"
    else
        echo "‚ö†Ô∏è  New drive health check failed or not yet available"
        echo "üí° This may be normal for a brand new drive"
    fi
    
    # Validate drive accessibility
    echo ""
    echo "üì° Accessibility Validation:"
    local new_drive_info
    if new_drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "‚úÖ New drive is accessible and mapped correctly"
        echo "   Drive: $(echo "$new_drive_info" | awk '{print $1}')"
    else
        echo "‚ùå New drive not accessible - may need system restart"
    fi
    
    # Show updated drive layout
    echo ""
    echo "üìä Updated Drive Layout:"
    pooltool drivemap --numbered --health --capacity
    
    echo ""
    echo "üìã Replacement Summary:"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "‚Ä¢ Position: $target_position"
    echo "‚Ä¢ Old Drive: $REPLACE_TARGET_DRIVE ($REPLACE_TARGET_MODEL)"
    echo "‚Ä¢ Status: Replacement completed"
    echo "‚Ä¢ Data Migration: Completed"
    echo "‚Ä¢ Validation: Passed"
    
    echo ""
    echo "üéØ Next Steps:"
    echo "‚Ä¢ Monitor the new drive for the first few days"
    echo "‚Ä¢ Run a full SnapRAID scrub to verify data integrity"
    echo "‚Ä¢ Update any drive documentation or labels"
    echo "‚Ä¢ Consider running extended health tests"
    
    echo ""
    if pooltool::question -p "Mark replacement as fully validated and complete?" -d "y"; then
        echo "‚úÖ Drive replacement validation completed successfully"
        return 0
    else
        echo "‚ö†Ô∏è  Validation marked as incomplete - monitor manually"
        return 0
    fi
}

#
# Show detailed drive information during assessment
#
replace_show_drive_details() {
    local position="$1"
    local drive_name="$2"
    local device_path="$3"
    local model="$4"
    
    echo "üè∑Ô∏è  Drive Identity:"
    echo "   Position: $position"
    echo "   Name: $drive_name"
    echo "   Device: $device_path"
    echo "   Model: $model"
    
    # Get health information
    echo ""
    echo "üè• Health Status:"
    if pooltool health "$position" 2>/dev/null; then
        echo "   ‚úÖ Health data available"
    else
        echo "   ‚ö†Ô∏è  Health data unavailable"
    fi
    
    # Get capacity information
    echo ""
    echo "üíæ Capacity Information:"
    local capacity_info
    if capacity_info=$(df -h "$device_path"* 2>/dev/null | grep "$device_path"); then
        echo "   üìä $(echo "$capacity_info" | awk '{print "Used: " $3 "/" $2 " (" $5 ")"}')"
    else
        echo "   üìä Capacity information unavailable (drive may not be mounted)"
    fi
    
    # Check SnapRAID role
    echo ""
    echo "üóÑÔ∏è  Array Integration:"
    echo "   üí° SnapRAID role detection not yet implemented"
    echo "   üí° Check SnapRAID configuration for drive role"
}

#
# SnapRAID parity rebuild migration method (enhanced with disk command logic)
#
replace_migration_snapraid_rebuild() {
    local target_position="$1"
    
    echo "üîÑ SnapRAID Parity Rebuild Method"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    
    # Check if this is a parity drive
    if [[ "$REPLACE_TARGET_DRIVE" =~ PPU[0-9]+ ]]; then
        echo "‚ö†Ô∏è  PARITY DRIVE REPLACEMENT DETECTED"
        echo "Parity drives require different handling than data drives."
        echo ""
        echo "üìã Parity Drive Replacement Process:"
        echo "1. Update SnapRAID configuration with new drive"
        echo "2. Run: snapraid sync (to rebuild parity on new drive)"
        echo "3. Run: snapraid scrub (to verify integrity)"
        echo ""
    else
        echo "üìã Data Drive Replacement Process:"
        echo "1. Update SnapRAID configuration if needed"
        echo "2. Run: snapraid fix -d $REPLACE_TARGET_DRIVE"
        echo "3. Run: snapraid scrub -d $REPLACE_TARGET_DRIVE"
        echo ""
    fi
    
    echo "‚ö†Ô∏è  SnapRAID Integration Notice:"
    echo "SnapRAID operations can take several hours to complete."
    echo "You can run them in the background and monitor progress."
    echo ""
    
    local run_background="false"
    if pooltool::question -p "Run SnapRAID operations in background?" -d "y"; then
        run_background="true"
    fi
    
    if [[ "$run_background" == "true" ]]; then
        echo "üîÑ SnapRAID operations will run in background"
        echo "Use 'pooltool monitor' to track progress"
        this::start_snapraid_recovery_background "$REPLACE_TARGET_DRIVE"
        return 0
    else
        echo "‚ö†Ô∏è  You will need to run SnapRAID commands manually:"
        if [[ "$REPLACE_TARGET_DRIVE" =~ PPU[0-9]+ ]]; then
            echo "  1. snapraid sync"
            echo "  2. snapraid scrub"
        else
            echo "  1. snapraid fix -d $REPLACE_TARGET_DRIVE"
            echo "  2. snapraid scrub -d $REPLACE_TARGET_DRIVE"
        fi
    fi
    
    if ! pooltool::question -p "Have you prepared for SnapRAID rebuild process?" -d "n"; then
        echo "‚ö†Ô∏è  SnapRAID rebuild preparation not confirmed"
        return 1
    fi
    
    return 0
}

#
# Manual data copy migration method (enhanced with disk command rsync approach)
#
replace_migration_manual_copy() {
    local target_position="$1"
    
    echo "üìã Manual Data Copy Setup (Enhanced)"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    
    # Check if we have the old drive data available
    local old_mountpoint=""
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    local snapraid_names=( $(snapraid::devices names) )
    
    # Find the old drive's mount point
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$REPLACE_TARGET_DRIVE" ]]; then
            old_mountpoint="${snapraid_mountpoints[i]}"
            break
        fi
    done
    
    if [[ -n "$old_mountpoint" && -d "$old_mountpoint" ]]; then
        echo "‚úÖ Old drive data found at: $old_mountpoint"
        echo ""
        
        if pooltool::question -p "Do you want to use automated rsync copy from the old drive?" -d "y"; then
            replace_migration_automated_rsync "$target_position" "$old_mountpoint"
            return $?
        fi
    else
        echo "‚ö†Ô∏è  Old drive mount point not accessible: $old_mountpoint"
        echo "Proceeding with manual copy instructions."
    fi
    
    echo ""
    echo "üìã Manual Data Copy Instructions:"
    echo ""
    echo "1Ô∏è‚É£  Prepare the new drive:"
    echo "   ‚Ä¢ Partition: sudo sgdisk -n 0:0:0 -c 0:\"$REPLACE_TARGET_DRIVE\" -t 0:8300 /dev/NEW_DRIVE"
    echo "   ‚Ä¢ Format: sudo mkfs.ext4 -L \"$REPLACE_TARGET_DRIVE\" /dev/NEW_DRIVE1"
    echo "   ‚Ä¢ Mount: sudo mount /dev/NEW_DRIVE1 /mnt/replacement"
    echo ""
    echo "2Ô∏è‚É£  Copy data using rsync (from disk command proven method):"
    echo "   ‚Ä¢ Command: sudo rsync -haxHAWXS --numeric-ids --info=progress2 SOURCE/ /mnt/replacement/"
    echo "   ‚Ä¢ Flags explanation:"
    echo "     -h: Human-readable output"
    echo "     -a: Archive mode (preserve permissions, times, etc.)"
    echo "     -x: Don't cross filesystem boundaries"
    echo "     -H: Preserve hard links"
    echo "     -A: Preserve ACLs"
    echo "     -W: Copy whole files (no delta transfer)"
    echo "     -X: Preserve extended attributes"
    echo "     -S: Handle sparse files efficiently"
    echo "     --numeric-ids: Preserve numeric user/group IDs"
    echo "     --info=progress2: Show progress information"
    echo ""
    echo "3Ô∏è‚É£  Update system configuration:"
    echo "   ‚Ä¢ Update /etc/fstab with new drive UUID"
    echo "   ‚Ä¢ Update SnapRAID configuration"
    echo "   ‚Ä¢ Test mounting and accessibility"
    echo ""
    
    if ! pooltool::question -p "Have you completed the manual data copy setup?" -d "n"; then
        echo "‚ö†Ô∏è  Manual copy not completed - marked for manual completion"
        return 1
    fi
    
    return 0
}

#
# Automated rsync copy method (based on disk command implementation)
#
replace_migration_automated_rsync() {
    local target_position="$1"
    local source_path="$2"
    local username="$(id -nu)"
    local runid="$(uuidgen)"
    
    echo "üîÑ Automated Rsync Copy Process"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Source: $source_path"
    echo "Target: Will be prompted for new drive device"
    echo ""
    
    # Get new drive device path
    local new_drive_device
    while [[ -z "$new_drive_device" ]]; do
        new_drive_device=$(bashful input -p "Enter the new drive device path (e.g., /dev/sdi): " -d "")
        
        if [[ ! -b "$new_drive_device" ]]; then
            echo "‚ùå $new_drive_device is not a valid block device"
            new_drive_device=""
            continue
        fi
        
        # Remove any partition numbers
        new_drive_device="${new_drive_device%%[[:digit:]]}"
    done
    
    echo ""
    echo "üõ†Ô∏è  Preparing new drive..."
    
    # Check for existing partitions (based on disk command logic)
    local diskparts
    IFS=$'\n' read -d '' -ra diskparts <<< "$(lsblk -lo "TYPE,NAME,MOUNTPOINT" "$new_drive_device" | tail -n +2 | awk -v u="part" '$1 == u { print $2":"$3 }')"
    
    if [[ ${#diskparts[@]} -gt 0 ]]; then
        echo "‚ö†Ô∏è  Drive has existing partitions:"
        for diskpart in "${diskparts[@]}"; do
            echo "   ${diskpart}"
        done
        
        echo ""
        echo "‚ùå Continuing will ERASE ALL DATA on $new_drive_device"
        if ! pooltool::question -p "Are you sure you want to continue?" -d "n"; then
            echo "‚ùå Operation cancelled"
            return 1
        fi
        
        # Unmount any mounted partitions
        local mountpoints=()
        for diskpart in "${diskparts[@]}"; do
            if [[ "${diskpart#*:}" != "" ]]; then
                mountpoints+=( "${diskpart#*:}" )
            fi
        done
        
        if [[ ${#mountpoints[@]} -gt 0 ]]; then
            echo "üì§ Unmounting existing partitions..."
            snown::sudo umount "${mountpoints[@]}" 2>/dev/null || true
        fi
        
        # Clear partition table
        echo "üóëÔ∏è  Clearing partition table..."
        snown::sudo sgdisk -Z "$new_drive_device"
    fi
    
    # Create new partition and filesystem
    echo "üìù Creating partition and filesystem..."
    snown::sudo sgdisk -n 0:0:0 -c 0:"$REPLACE_TARGET_DRIVE" -t 0:8300 "$new_drive_device"
    snown::sudo mkfs.ext4 -L "$REPLACE_TARGET_DRIVE" "${new_drive_device}1"
    
    # Create temporary mount point
    local temp_mountpoint="/media/${username}/${runid}"
    snown::sudo mkdir -p "$temp_mountpoint"
    snown::sudo mount -t ext4 "${new_drive_device}1" "$temp_mountpoint"
    snown::sudo chown "$username" "$temp_mountpoint"
    
    echo "‚úÖ New drive prepared and mounted at: $temp_mountpoint"
    echo ""
    
    # Estimate copy time and size
    echo "üìä Analyzing source data..."
    local source_size=$(du -sh "$source_path" 2>/dev/null | awk '{print $1}')
    echo "Source data size: $source_size"
    echo ""
    
    # Confirm copy operation
    echo "üöÄ Ready to start data copy:"
    echo "   Source: $source_path"
    echo "   Destination: $temp_mountpoint"
    echo "   Method: rsync with proven flags from disk command"
    echo ""
    echo "‚è±Ô∏è  This operation may take several hours depending on data size."
    echo "üìß You will receive email notification when complete (if configured)."
    echo ""
    
    if ! pooltool::question -p "Start the data copy now?" -d "y"; then
        echo "‚ùå Data copy cancelled"
        snown::sudo umount "$temp_mountpoint"
        snown::sudo rmdir "$temp_mountpoint"
        return 1
    fi
    
    # Save progress state (based on disk command)
    local progress_mark="replace_drive_copy_data"
    declare -p runid username new_drive_device source_path temp_mountpoint progress_mark > "${HOME}/.pooltool.replace.${runid}"
    
    echo "üîÑ Starting background rsync copy..."
    echo "   Progress file: ${HOME}/.pooltool.replace.${runid}"
    echo "   Temp mount: $temp_mountpoint"
    echo ""
    
    # Start background rsync (enhanced from disk command)
    snown::sudo screen -dmS "replace_${runid}" bash -c "
        rsync -haxHAWXS --numeric-ids --info=progress2 \
            '$source_path/' '$temp_mountpoint/' && \
        echo 'Rsync completed successfully' > '$temp_mountpoint/.rsync_complete' || \
        echo 'Rsync failed with error $?' > '$temp_mountpoint/.rsync_error'
    "
    
    echo "‚úÖ Background copy started with session: replace_${runid}"
    echo ""
    echo "üìã Monitor progress with:"
    echo "   screen -r replace_${runid}  # Attach to copy session"
    echo "   df -h $temp_mountpoint      # Check space usage"
    echo "   ls -la $temp_mountpoint     # Check files being copied"
    echo ""
    echo "üí° The copy will continue in the background. You can safely close this terminal."
    echo "   The wizard will check for completion when you proceed to the next step."
    
    # Store rsync session info globally
    REPLACE_RSYNC_RUNID="$runid"
    REPLACE_RSYNC_MOUNTPOINT="$temp_mountpoint"
    REPLACE_NEW_DEVICE="${new_drive_device}1"
    
    return 0
}

#
# Upgrade-specific automated rsync (uses pre-selected device)
#
replace_upgrade_automated_rsync() {
    local target_position="$1"
    local source_path="$2"
    local new_drive_device="$3"  # Pre-selected device, no prompting
    local username="$(id -nu)"
    local runid="$(uuidgen)"
    
    echo "üîÑ Automated Rsync Copy Process"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Source: $source_path"
    echo "Target: $new_drive_device (pre-selected)"
    echo ""
    
    # Validate the pre-selected device
    if [[ ! -b "$new_drive_device" ]]; then
        echo "‚ùå $new_drive_device is not a valid block device"
        echo "üí° The target drive may have been disconnected"
        return 1
    fi
    
    # Remove any partition numbers
    new_drive_device="${new_drive_device%%[[:digit:]]}"
    
    echo "üõ†Ô∏è  Preparing new drive..."
    echo "   Device: $new_drive_device"
    echo ""
    
    # Format the new drive
    echo "üìÅ Creating filesystem on $new_drive_device..."
    echo "   ‚è≥ Step 1/4: Creating partition table..."
    
    # Create a single partition taking the full disk
    snown::sudo parted "$new_drive_device" --script mklabel gpt mkpart primary ext4 0% 100%
    
    # Wait for partition to appear
    echo "   ‚è≥ Step 2/4: Waiting for partition to appear..."
    sleep 2
    
    # Format with ext4
    local partition="${new_drive_device}1"
    echo "   ‚è≥ Step 3/4: Formatting ${partition} with ext4..."
    snown::sudo mkfs.ext4 -F "$partition"
    
    # Create temporary mount point
    local temp_mountpoint="/tmp/new_drive_${runid}"
    snown::sudo mkdir -p "$temp_mountpoint"
    
    # Mount the new drive
    echo "   ‚è≥ Step 4/4: Mounting ${partition} at $temp_mountpoint"
    snown::sudo mount "$partition" "$temp_mountpoint"
    
    echo "   ‚úÖ Drive preparation completed!"
    echo ""
    
    # Present user with execution mode choice
    echo "üöÄ Data Copy Operation Setup"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "   Source: $source_path"
    echo "   Target: $temp_mountpoint"
    echo "   This may take several hours depending on data size"
    echo ""
    echo "Choose execution mode:"
    echo ""
    echo "üì∫ [F]oreground - Watch progress in real-time"
    echo "   ‚Ä¢ Live progress updates and completion status"
    echo "   ‚Ä¢ Terminal stays busy until completion"
    echo "   ‚Ä¢ Good for local sessions and smaller transfers"
    echo ""
    echo "ÔøΩ [B]ackground - SSH-safe long-running transfer"
    echo "   ‚Ä¢ Continues running if SSH disconnects"
    echo "   ‚Ä¢ Can return to workflow anytime" 
    echo "   ‚Ä¢ Perfect for remote sessions and large transfers"
    echo "   ‚Ä¢ Monitor via: pooltool rsync status $runid"
    echo ""
    echo "‚ùå [C]ancel - Return to previous step"
    echo ""
    
    while true; do
        read -p "Select mode [F/B/C] (default: F): " mode_choice
        
        # Handle empty input (default to F)
        if [[ -z "$mode_choice" ]]; then
            mode_choice="F"
        fi
        
        case "$mode_choice" in
            [Ff])
                echo "üì∫ Starting foreground transfer..."
                echo ""
                if replace_upgrade_rsync_foreground "$source_path" "$temp_mountpoint" "$runid"; then
                    echo "‚úÖ Foreground transfer completed successfully!"
                    break
                else
                    echo "‚ùå Foreground transfer failed"
                    return 1
                fi
                ;;
            [Bb])
                echo "üîÑ Starting background transfer..."
                echo ""
                if replace_upgrade_rsync_background "$source_path" "$temp_mountpoint" "$runid"; then
                    echo "‚úÖ Background transfer initiated successfully!"
                    echo "üí° Use 'pooltool rsync status $runid' to monitor progress"
                    echo "üí° Return to this workflow anytime to continue"
                    break
                else
                    echo "‚ùå Background transfer failed to start"
                    return 1
                fi
                ;;
            [Cc])
                echo "üîô Cancelled. Returning to previous step..."
                return 1
                ;;
            *)
                echo "‚ùì Please select F, B, or C"
                ;;
        esac
    done
    
    # Store rsync session info globally
    REPLACE_RSYNC_RUNID="$runid"
    REPLACE_RSYNC_MOUNTPOINT="$temp_mountpoint"
    REPLACE_NEW_DEVICE="${new_drive_device}1"
    
    return 0
}

#
# New empty drive migration method
#
replace_migration_new_empty() {
    local target_position="$1"
    
    echo "üìÅ New Empty Drive Configuration:"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Setting up the new drive for fresh use..."
    echo ""
    echo "üí° The new drive will be available for:"
    echo "‚Ä¢ New data storage"
    echo "‚Ä¢ Array expansion"
    echo "‚Ä¢ Dedicated application use"
    echo ""
    echo "üìã Recommended next steps:"
    echo "‚Ä¢ Partition and format the drive as needed"
    echo "‚Ä¢ Add to SnapRAID configuration if desired"
    echo "‚Ä¢ Configure mounting in /etc/fstab"
    echo "‚Ä¢ Run health checks to ensure drive stability"
    
    if pooltool::question -p "Configure the drive for immediate use?" -d "y"; then
        echo "üõ†Ô∏è  Basic drive preparation would go here"
        echo "üí° Full drive preparation tools will be added in future versions"
    fi
    
    return 0
}

# Initialize drive replacement wizard
replace_drive_init

#
# Upgrade workflow step functions
#

#
# Upgrade Step 1: Assess source drive for upgrade
#
replace_upgrade_step_source_assessment() {
    local target_position="$1"
    
    echo "üìä Step 1: Source Drive Assessment for Upgrade"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Show current drive layout
    echo "Current Drive Layout:"
    
    # Use a simpler, non-blocking drive overview for the wizard
    echo "üìã Quick Drive Overview:"
    echo "   Checking SnapRAID configuration..."
    
    # Get SnapRAID drive count without expensive operations
    local snapraid_names=( $(snapraid::devices names 2>/dev/null || echo) )
    local drive_count=${#snapraid_names[@]}
    
    if [[ $drive_count -gt 0 ]]; then
        echo "   ‚úÖ SnapRAID array detected with $drive_count drives"
        echo "   üìç For detailed drive layout, run: pooltool drivemap"
    else
        echo "   ‚ö†Ô∏è  No SnapRAID configuration detected"
    fi
    
    echo ""
    
    # Get source drive selection if not provided
    if [[ -z "$target_position" ]]; then
        echo "üìã Which drive would you like to upgrade?"
        echo ""
        
        while true; do
            local user_input
            user_input=$(bashful input -p "Enter the position number (1-24) of the drive to upgrade: " -d "")
            
            if [[ "$user_input" == "q" || "$user_input" == "quit" ]]; then
                echo "‚ùå Drive upgrade cancelled by user"
                return 1
            elif [[ "$user_input" =~ ^[0-9]+$ ]] && [[ $user_input -ge 1 ]] && [[ $user_input -le 24 ]]; then
                target_position="$user_input"
                break
            else
                echo "‚ùå Invalid position. Please enter a number between 1 and 24, or 'q' to quit."
            fi
        done
    fi
    
    # Validate source drive exists and is accessible
    local drive_info
    if ! drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "‚ùå No drive found at position $target_position"
        return 1
    fi
    
    # Parse drive information  
    local drive_name device_path model
    read -r drive_name device_path model <<< "$drive_info"
    
    # Check if drive is currently accessible
    if [[ ! -b "$device_path" ]]; then
        echo "‚ùå Source drive $device_path is not accessible"
        echo "üí° This might be a failed drive - consider using recovery workflow instead"
        return 1
    fi
    
    echo "üìä Source Drive Analysis:"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    
    # Show detailed source drive information
    replace_show_drive_details "$target_position" "$drive_name" "$device_path" "$model"
    replace_show_snapraid_integration "$drive_name"
    
    # Determine drive type for upgrade considerations
    local drive_type="data"
    if [[ "$drive_name" =~ PPU[0-9]+ ]]; then
        drive_type="parity"
        echo ""
        echo "‚ö†Ô∏è  PARITY DRIVE UPGRADE DETECTED"
        echo "Parity drives require special considerations:"
        echo "‚Ä¢ Parity drives can be safely upgraded with direct copy"
        echo "‚Ä¢ New drive must be same size or larger"
        echo "‚Ä¢ SnapRAID will need to rebuild parity after upgrade"
    fi
    
    # Check current health status
    echo ""
    echo "üè• Health Check:"
    if pooltool health "$target_position" --quiet 2>/dev/null; then
        echo "‚úÖ Source drive is healthy and accessible"
    else
        echo "‚ö†Ô∏è  Source drive has health issues or is not accessible"
        echo "üí° Consider using recovery workflow for failed drives"
        
        if ! pooltool::question -p "Continue with upgrade despite health warnings?" -d "n"; then
            echo "‚ùå Upgrade cancelled due to health concerns"
            return 1
        fi
    fi
    
    # Store source drive information globally
    REPLACE_TARGET_POSITION="$target_position"
    REPLACE_TARGET_DRIVE="$drive_name"
    REPLACE_TARGET_DEVICE="$device_path"
    REPLACE_TARGET_MODEL="$model"
    REPLACE_DRIVE_TYPE="$drive_type"
    
    echo ""
    echo "‚úÖ Source drive assessment completed - Ready for upgrade planning"
    return 0
}

#
# Upgrade Step 2: Validate new drive preparation
#
replace_upgrade_step_new_drive_prep() {
    echo ""
    echo "üíΩ Step 2: New Drive Validation"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Verify the target drive is still available and accessible
    if [[ ! -b "$REPLACE_NEW_DEVICE" ]]; then
        echo "‚ùå Target drive $REPLACE_NEW_DEVICE is no longer accessible"
        echo "üí° Please ensure the drive is properly connected"
        return 1
    fi
    
    # Display drive information
    local target_size_human=$(lsblk -dno SIZE "$REPLACE_NEW_DEVICE" | head -1)
    local target_model=$(lsblk -dno MODEL "$REPLACE_NEW_DEVICE" | head -1 | xargs)
    local source_size_human=$(lsblk -dno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
    
    echo "‚úÖ Target drive confirmed:"
    echo "   Device: $REPLACE_NEW_DEVICE"
    echo "   Size: $target_size_human"
    echo "   Model: $target_model"
    echo ""
    
    echo "ÔøΩ Source drive:"
    echo "   Device: $REPLACE_TARGET_DEVICE"
    echo "   Size: $source_size_human"
    echo ""
    
    # Check if target drive has any existing data/partitions
    local partition_count=$(lsblk -no NAME "$REPLACE_NEW_DEVICE" | wc -l)
    if [[ $partition_count -gt 1 ]]; then
        echo "‚ö†Ô∏è  Target drive has existing partitions:"
        lsblk "$REPLACE_NEW_DEVICE"
        echo ""
        echo "üö® WARNING: All data on the target drive will be destroyed!"
        echo ""
        
        read -p "Continue with upgrade (this will ERASE the target drive)? [y/N] (default: N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "‚ùå Upgrade cancelled by user"
            return 1
        fi
    fi
    
    echo "‚úÖ Target drive validation completed"
    return 0
}

#
# Upgrade Step 3: Verify capacity and compatibility
#
replace_upgrade_step_compatibility_check() {
    echo ""
    echo "üîç Step 3: Capacity and Compatibility Check"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    echo "üìä Upgrade Compatibility Analysis:"
    echo ""
    printf "%-15s %-15s %-20s %-10s\n" "Component" "Source" "New" "Status"
    printf "%-15s %-15s %-20s %-10s\n" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 20 '' | tr ' ' '-')" "$(printf '%*s' 10 '' | tr ' ' '-')"
    
    # Size comparison
    local source_size_human=$(lsblk -hno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
    local size_status="‚úÖ OK"
    
    local source_size_bytes=$(lsblk -bno SIZE "$REPLACE_TARGET_DEVICE" | head -1)
    local new_size_bytes=$(lsblk -bno SIZE "$REPLACE_NEW_DEVICE" | head -1)
    
    if [[ $new_size_bytes -lt $source_size_bytes ]]; then
        size_status="‚ùå SMALLER"
    elif [[ $new_size_bytes -gt $source_size_bytes ]]; then
        size_status="‚úÖ LARGER"
    fi
    
    printf "%-15s %-15s %-20s %-10s\n" "Drive Size" "$source_size_human" "$REPLACE_NEW_SIZE" "$size_status"
    printf "%-15s %-15s %-20s %-10s\n" "Model" "$REPLACE_TARGET_MODEL" "$REPLACE_NEW_MODEL" "‚úÖ OK"
    printf "%-15s %-15s %-20s %-10s\n" "Drive Type" "$REPLACE_DRIVE_TYPE" "$REPLACE_DRIVE_TYPE" "‚úÖ SAME"
    
    # Check for existing partitions on new drive
    echo ""
    echo "üîç New Drive Partition Check:"
    
    local partitions
    partitions=$(lsblk -lno NAME,TYPE "$REPLACE_NEW_DEVICE" | awk '$2=="part" {print $1}')
    
    if [[ -n "$partitions" ]]; then
        echo "‚ö†Ô∏è  New drive has existing partitions:"
        lsblk "$REPLACE_NEW_DEVICE"
        echo ""
        echo "‚ùå CONTINUING WILL ERASE ALL DATA ON THE NEW DRIVE"
        
        if ! pooltool::question -p "Are you sure you want to erase the new drive?" -d "n"; then
            echo "‚ùå Compatibility check cancelled"
            return 1
        fi
    else
        echo "‚úÖ New drive is clean (no existing partitions)"
    fi
    
    # Estimate copy time
    echo ""
    echo "‚è±Ô∏è  Upgrade Time Estimation:"
    
    local source_used=""
    if mount | grep -q "$REPLACE_TARGET_DEVICE"; then
        source_used=$(df -h "$REPLACE_TARGET_DEVICE"* 2>/dev/null | tail -1 | awk '{print $3}')
        echo "   Data to copy: $source_used"
        echo "   Estimated time: 2-8 hours (depends on data size and drive speed)"
    else
        echo "   Cannot estimate - source drive not mounted"
        echo "   Estimated time: 4-12 hours (full drive copy)"
    fi
    
    echo ""
    echo "üéØ Upgrade Summary:"
    echo "   Source: $REPLACE_TARGET_DRIVE ($REPLACE_TARGET_MODEL, $source_size_human)"
    echo "   Target: $REPLACE_NEW_DEVICE ($REPLACE_NEW_MODEL, $REPLACE_NEW_SIZE)"
    echo "   Method: Direct rsync copy with background processing"
    echo "   Risk Level: üü¢ LOW (source drive remains untouched)"
    
    echo ""
    if ! pooltool::question -p "Proceed with this upgrade configuration?" -d "y"; then
        echo "‚ùå Compatibility check failed - user cancelled"
        return 1
    fi
    
    echo "‚úÖ Compatibility check passed - Ready for data copy"
    return 0
}

#
# Upgrade Step 5: Perform the data copy
#
replace_upgrade_step_data_copy() {
    echo ""
    echo "üì¶ Step 5: Data Copy Process"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # For upgrade workflow, we already have the target device selected
    echo "üîÑ Starting automated data copy from source to new drive..."
    echo "   Source: $REPLACE_TARGET_DEVICE"
    echo "   Target: $REPLACE_NEW_DEVICE"
    echo ""
    
    # Find source drive mount point
    local source_mountpoint=""
    local snapraid_mountpoints=( $(snapraid::devices mountpoints) )
    local snapraid_names=( $(snapraid::devices names) )
    
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$REPLACE_TARGET_DRIVE" ]]; then
            source_mountpoint="${snapraid_mountpoints[i]}"
            break
        fi
    done
    
    if [[ -z "$source_mountpoint" || ! -d "$source_mountpoint" ]]; then
        echo "‚ùå Cannot find source drive mount point"
        echo "üí° Source drive may not be properly mounted"
        return 1
    fi
    
    echo "‚úÖ Source mount point found: $source_mountpoint"
    
    # Use upgrade-specific rsync with pre-selected device
    replace_upgrade_automated_rsync "$REPLACE_TARGET_POSITION" "$source_mountpoint" "$REPLACE_NEW_DEVICE"
    return $?
}

#
# Upgrade Step 6: Perform the drive swap
#
replace_upgrade_step_drive_swap() {
    echo ""
    echo "üîÑ Step 6: Drive Swap Process"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    echo "üìã Drive Swap Instructions:"
    echo ""
    echo "üîç Current Configuration:"
    echo "   Source drive: $REPLACE_TARGET_DRIVE at position $REPLACE_TARGET_POSITION"
    echo "   New drive: $REPLACE_NEW_DEVICE (currently connected for copy)"
    echo ""
    echo "üîÑ Swap Process:"
    echo "1Ô∏è‚É£  Unmount the source drive from SnapRAID"
    echo "2Ô∏è‚É£  Update SnapRAID configuration"  
    echo "3Ô∏è‚É£  Mount the new drive in place of the old drive"
    echo "4Ô∏è‚É£  Update system mount points (/etc/fstab)"
    echo ""
    
    # Check if rsync copy completed
    if [[ -n "$REPLACE_RSYNC_MOUNTPOINT" && -f "$REPLACE_RSYNC_MOUNTPOINT/.rsync_complete" ]]; then
        echo "‚úÖ Data copy completed successfully"
    elif [[ -n "$REPLACE_RSYNC_MOUNTPOINT" && -f "$REPLACE_RSYNC_MOUNTPOINT/.rsync_error" ]]; then
        echo "‚ùå Data copy failed - cannot proceed with swap"
        echo "üí° Check the error and retry the copy process"
        return 1
    else
        echo "‚ö†Ô∏è  Cannot verify data copy completion"
        if ! pooltool::question -p "Proceed anyway?" -d "n"; then
            return 1
        fi
    fi
    
    echo ""
    echo "‚ö†Ô∏è  IMPORTANT: This step requires careful attention"
    echo "‚Ä¢ Ensure data copy is complete and verified"
    echo "‚Ä¢ Have the SnapRAID configuration ready to update"
    echo "‚Ä¢ Be prepared to update /etc/fstab with new drive UUID"
    
    echo ""
    if ! pooltool::question -p "Are you ready to perform the drive swap?" -d "n"; then
        echo "‚ùå Drive swap cancelled"
        return 1
    fi
    
    echo ""
    echo "üöß DRIVE SWAP IMPLEMENTATION IN PROGRESS"
    echo "This advanced step will be fully automated in the next iteration."
    echo ""
    echo "üìã Manual steps for now:"
    echo "1. Update SnapRAID config to point to new drive"
    echo "2. Update /etc/fstab with new drive UUID"
    echo "3. Unmount old drive and mount new drive"
    echo "4. Test accessibility and run SnapRAID sync"
    
    if ! pooltool::question -p "Have you completed the manual drive swap?" -d "n"; then
        echo "‚ö†Ô∏è  Drive swap not completed - marked for manual completion"
    fi
    
    return 0
}

#
# Add drive workflow step functions  
#
replace_add_step_capacity_assessment() {
    echo "üìä Add drive assessment implementation coming soon..."
    echo "This will assess current array capacity and recommend drive sizes."
    
    return 0
}

replace_add_step_integration() {
    echo "üîó Drive integration implementation coming soon..."
    echo "This will integrate new drives with SnapRAID configuration."
    
    return 0
}

#
# Recovery workflow step functions
#

#
# Recovery Step 1: Assess failed drive and recovery options
#
replace_recovery_step_failed_assessment() {
    local target_position="$1"
    
    echo ""
    echo "üö® Step 1: Failed Drive Assessment"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Get drive information at target position
    local drive_info
    if ! drive_info=$(get_drive_info_by_position "$target_position" 2>/dev/null); then
        echo "‚ùå Cannot retrieve drive information for position $target_position"
        echo "   This may indicate the drive has completely failed"
        
        # Still allow recovery if position mapping exists
        echo ""
        echo "üìã Recovery Assessment:"
        echo "‚Ä¢ Target Position: $target_position" 
        echo "‚Ä¢ Drive Status: Not accessible or completely failed"
        echo "‚Ä¢ Recovery Method: SnapRAID parity rebuild (recommended)"
        
        if pooltool::question -p "Proceed with failed drive recovery at position $target_position?" -d "y"; then
            # Store minimal target information for recovery
            REPLACE_TARGET_POSITION="$target_position"
            REPLACE_TARGET_DRIVE="FAILED_DRIVE_POS_$target_position"
            REPLACE_TARGET_DEVICE="NONE"
            REPLACE_TARGET_MODEL="Unknown (drive failed)"
            
            echo "‚úÖ Failed drive assessment completed - proceeding with recovery"
            return 0
        else
            echo "‚ùå Failed drive assessment cancelled by user"
            return 1
        fi
    fi
    
    # Parse drive information for accessible drive
    local drive_name device_path model
    read -r drive_name device_path model <<< "$drive_info"
    
    echo "üìä Failed Drive Analysis for Position $target_position:"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    
    # Show drive details
    replace_show_drive_details "$target_position" "$drive_name" "$device_path" "$model"
    
    echo ""
    echo "üîç Drive Health Assessment:"
    
    # Try to get health information
    local health_status="unknown"
    if [[ -b "$device_path" ]]; then
        local health_info
        if health_info=$(pooltool health "$target_position" --quiet 2>/dev/null); then
            echo "‚úÖ Drive is still accessible for health checks"
            echo "   Health Status: $health_info"
            
            # Determine if this is truly a failed drive or just a replacement
            echo ""
            echo "üí° Drive appears to be accessible. This may be:"
            echo "1Ô∏è‚É£  Preventive replacement (drive showing warnings)"
            echo "2Ô∏è‚É£  Failed drive replacement (drive has critical errors)"
            echo "3Ô∏è‚É£  Capacity upgrade (replacing working drive with larger one)"
            
            local failure_type
            while true; do
                failure_type=$(bashful input -p "What type of replacement is this? (1-3)" -d "2")
                case "$failure_type" in
                    1) 
                        echo "üîÑ Treating as preventive replacement"
                        break
                        ;;
                    2)
                        echo "üö® Treating as failed drive replacement" 
                        health_status="critical"
                        break
                        ;;
                    3)
                        echo "üìà This appears to be an upgrade - consider using upgrade workflow instead"
                        if pooltool::question -p "Continue with recovery workflow anyway?" -d "n"; then
                            break
                        else
                            return 1
                        fi
                        ;;
                    *)
                        echo "Please enter 1, 2, or 3"
                        ;;
                esac
            done
        else
            echo "‚ùå Drive health check failed - treating as failed drive"
            health_status="critical"
        fi
    else
        echo "‚ùå Drive device not accessible - drive has completely failed"
        health_status="failed"
    fi
    
    # Show SnapRAID integration details
    replace_show_snapraid_integration "$drive_name"
    
    echo ""
    echo "‚ö†Ô∏è  RECOVERY CONSIDERATIONS:"
    echo "‚Ä¢ Failed drive recovery uses SnapRAID parity to rebuild data"
    echo "‚Ä¢ Array must be in sync for safe recovery"
    echo "‚Ä¢ Recovery process may take 2-8 hours depending on drive size"
    echo "‚Ä¢ New replacement drive must be installed before data recovery"
    echo "‚Ä¢ System will remain operational during most of the process"
    
    echo ""
    if ! pooltool::question -p "Do you want to proceed with failed drive recovery at position $target_position?" -d "y"; then
        return 1
    fi
    
    # Store target information globally for other steps
    REPLACE_TARGET_POSITION="$target_position"
    REPLACE_TARGET_DRIVE="$drive_name"
    REPLACE_TARGET_DEVICE="$device_path"
    REPLACE_TARGET_MODEL="$model"
    REPLACE_HEALTH_STATUS="$health_status"
    
    echo "‚úÖ Failed drive assessment completed - Position $target_position confirmed for recovery"
    return 0
}

#
# Recovery Step 2: Check SnapRAID parity status and array health
#
replace_recovery_step_parity_check() {
    echo ""
    echo "üõ°Ô∏è  Step 2: SnapRAID Parity Check"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    echo "üîç Checking SnapRAID array status and parity health..."
    
    # Check if SnapRAID is configured
    local snapraid_config="/etc/snapraid.conf"
    if [[ ! -f "$snapraid_config" ]]; then
        echo "‚ùå SnapRAID configuration not found at $snapraid_config"
        echo "   Cannot proceed with parity-based recovery"
        return 1
    fi
    
    echo "‚úÖ SnapRAID configuration found"
    
    # Check SnapRAID status
    echo ""
    echo "üìä SnapRAID Array Status:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Run snapraid status to check array health
    local snapraid_status_output
    if snapraid_status_output=$(snapraid status 2>&1); then
        echo "‚úÖ SnapRAID status check completed"
        
        # Extract key information from status
        local sync_status=""
        local parity_status=""
        
        if echo "$snapraid_status_output" | grep -q "Everything OK"; then
            echo "‚úÖ Array status: Everything OK"
            sync_status="ok"
        elif echo "$snapraid_status_output" | grep -q "You have [0-9]* unsync"; then
            local unsync_count=$(echo "$snapraid_status_output" | grep -o "You have [0-9]* unsync" | grep -o "[0-9]*")
            echo "‚ö†Ô∏è  Array status: $unsync_count unsynchronized files detected"
            sync_status="unsync"
        else
            echo "‚ö†Ô∏è  Array status: Unknown - manual review required"
            sync_status="unknown"
        fi
        
        # Check for parity drive health
        echo ""
        echo "üîç Parity Drive Health:"
        local parity_drives=( $(snapraid::devices names | grep -E "^P[PU][UP][0-9]+" || true) )
        
        if [[ ${#parity_drives[@]} -gt 0 ]]; then
            for parity_drive in "${parity_drives[@]}"; do
                echo "   Checking $parity_drive..."
                local parity_health
                if parity_health=$(pooltool health --quiet | grep "$parity_drive" 2>/dev/null); then
                    echo "   ‚úÖ $parity_drive: $parity_health"
                else
                    echo "   ‚ö†Ô∏è  $parity_drive: Unable to check health"
                fi
            done
            echo "‚úÖ Parity drives appear operational"
            parity_status="ok"
        else
            echo "‚ùå No parity drives detected in array"
            parity_status="missing"
        fi
        
    else
        echo "‚ùå SnapRAID status check failed:"
        echo "$snapraid_status_output"
        return 1
    fi
    
    echo ""
    echo "üéØ Recovery Feasibility Assessment:"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    
    # Assess recovery feasibility based on status
    local recovery_safe=true
    local recovery_recommendations=()
    
    case "$sync_status" in
        "ok")
            echo "‚úÖ Array Sync Status: Perfect - safe for recovery"
            ;;
        "unsync")
            echo "‚ö†Ô∏è  Array Sync Status: Unsynchronized files detected"
            recovery_recommendations+=("Consider running 'snapraid sync' before recovery if possible")
            if [[ "$REPLACE_HEALTH_STATUS" == "failed" ]]; then
                echo "   Note: Sync may not be possible with failed drive"
            fi
            ;;
        "unknown")
            echo "‚ùì Array Sync Status: Unknown - manual assessment needed"
            recovery_safe=false
            ;;
    esac
    
    case "$parity_status" in
        "ok")
            echo "‚úÖ Parity Status: Available and healthy"
            ;;
        "missing")
            echo "‚ùå Parity Status: No parity drives available"
            echo "   Cannot perform parity-based recovery"
            recovery_safe=false
            ;;
    esac
    
    if [[ "$recovery_safe" == true ]]; then
        echo ""
        echo "üéâ RECOVERY ASSESSMENT: SAFE TO PROCEED"
        echo "‚úÖ SnapRAID parity recovery is feasible"
        
        if [[ ${#recovery_recommendations[@]} -gt 0 ]]; then
            echo ""
            echo "üí° Recommendations:"
            for rec in "${recovery_recommendations[@]}"; do
                echo "   ‚Ä¢ $rec"
            done
        fi
        
        echo ""
        if pooltool::question -p "Proceed with SnapRAID parity-based recovery?" -d "y"; then
            echo "‚úÖ Parity check completed - recovery approved"
            return 0
        else
            echo "‚ùå Recovery cancelled by user"
            return 1
        fi
    else
        echo ""
        echo "üö® RECOVERY ASSESSMENT: NOT SAFE"
        echo "‚ùå Parity-based recovery is not feasible with current array status"
        echo ""
        echo "üõ†Ô∏è  Manual Recovery Options:"
        echo "1. Restore from backup if available"
        echo "2. Attempt manual data recovery if drive is partially accessible"
        echo "3. Accept data loss and initialize new drive"
        
        echo ""
        if pooltool::question -p "Do you want to continue anyway with alternative recovery?" -d "n"; then
            echo "‚ö†Ô∏è  Proceeding with alternative recovery - data loss possible"
            return 0
        else
            echo "‚ùå Recovery workflow aborted due to unsafe conditions"
            return 1
        fi
    fi
}

#
# Common utility functions used across all workflows
#

#
# Show detailed information about a drive
#
replace_show_drive_details() {
    local position="$1"
    local drive_name="$2"
    local device_path="$3"
    local model="$4"
    
    printf "%-15s %s\n" "Position:" "$position"
    printf "%-15s %s\n" "Drive Name:" "$drive_name"
    printf "%-15s %s\n" "Device Path:" "$device_path"
    printf "%-15s %s\n" "Model:" "$model"
    
    if [[ -b "$device_path" ]]; then
        local size_human=$(lsblk -hno SIZE "$device_path" | head -1)
        local filesystem=$(lsblk -no FSTYPE "$device_path"* | head -1 | xargs)
        
        printf "%-15s %s\n" "Size:" "$size_human"
        [[ -n "$filesystem" ]] && printf "%-15s %s\n" "Filesystem:" "$filesystem"
        
        # Show mount status
        local mount_info
        mount_info=$(mount | grep "$device_path" | head -1)
        if [[ -n "$mount_info" ]]; then
            local mount_point=$(echo "$mount_info" | awk '{print $3}')
            printf "%-15s %s\n" "Mounted:" "$mount_point"
            
            # Show usage if mounted
            local usage_info
            usage_info=$(df -h "$mount_point" 2>/dev/null | tail -1)
            if [[ -n "$usage_info" ]]; then
                local used=$(echo "$usage_info" | awk '{print $3}')
                local available=$(echo "$usage_info" | awk '{print $4}')
                local use_percent=$(echo "$usage_info" | awk '{print $5}')
                
                printf "%-15s %s used, %s available (%s)\n" "Usage:" "$used" "$available" "$use_percent"
            fi
        else
            printf "%-15s %s\n" "Mounted:" "No"
        fi
    else
        printf "%-15s %s\n" "Status:" "‚ùå Not accessible"
    fi
}

#
# Show SnapRAID integration details for a drive
#
replace_show_snapraid_integration() {
    local drive_name="$1"
    
    echo ""
    echo "üõ°Ô∏è  SnapRAID Integration:"
    
    # Check if drive is in SnapRAID config
    local snapraid_names=( $(snapraid::devices names) )
    local snapraid_paths=( $(snapraid::devices mountpoints) )
    local snapraid_found=false
    local drive_index=""
    
    for (( i = 0; i < ${#snapraid_names[@]}; i++ )); do
        if [[ "${snapraid_names[i]}" == "$drive_name" ]]; then
            snapraid_found=true
            drive_index=$i
            break
        fi
    done
    
    if [[ "$snapraid_found" == true ]]; then
        echo "‚úÖ Drive is configured in SnapRAID array"
        printf "%-15s %s\n" "SnapRAID Path:" "${snapraid_paths[drive_index]}"
        
        # Check for parity drive
        if [[ "$drive_name" =~ PPU[0-9]+ ]]; then
            echo "üõ°Ô∏è  Drive Type: Parity Drive"
            echo "üí° Parity drives protect other drives in the array"
        else
            echo "üì¶ Drive Type: Data Drive"
            echo "üí° Data drives contain your actual files"
        fi
        
        # Show last SnapRAID sync status
        echo ""
        echo "üìÖ Last SnapRAID Status:"
        if command -v snapraid >/dev/null 2>&1; then
            # Try to get status (non-blocking)
            timeout 5s snapraid status 2>/dev/null | grep -E "(Everything OK|WARNING|ERROR)" | head -3 || echo "   Status check timed out"
        else
            echo "   SnapRAID command not available"
        fi
    else
        echo "‚ùå Drive is NOT in SnapRAID array"
        echo "ÔøΩ This drive is not protected by SnapRAID parity"
    fi
}

#
# Get drive information by position using driveutils unified mapping
#
get_drive_info_by_position() {
    local position="$1"
    
    # Convert position number (1-24) to connector/device coordinates
    # Position formula: connector * 4 + (4 - device) = position
    # Reverse: connector = (position - 1) / 4, device = 4 - ((position - 1) % 4) - 1
    
    local connector=$(( (position - 1) / 4 ))
    local device=$(( 4 - ((position - 1) % 4) - 1 ))
    
    # Load driveutils module to access unified mapping function
    bootstrap_load_module pooltool/driveutils >/dev/null 2>&1
    
    # Get unified mapping data 
    local unified_data
    if ! unified_data=$(pooltool::create_unified_mapping 1 2>/dev/null); then
        echo "UNKNOWN /dev/unknown Unknown_Model"
        return 1
    fi
    
    # Parse unified data to find drive at this connector/device position
    while IFS= read -r record; do
        if [[ -n "$record" ]]; then
            # Parse record: name:arcconf_id:connector:device_slot:snapraid_name:device_path:wwn:serial:channel:device_num:model:size:match_method
            if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
                local drive_name="${BASH_REMATCH[1]}"
                local arcconf_id="${BASH_REMATCH[2]}"
                local rec_connector="${BASH_REMATCH[3]}"
                local rec_device="${BASH_REMATCH[4]}"
                local snapraid_name="${BASH_REMATCH[5]}"
                local device_path="${BASH_REMATCH[6]}"
                local wwn="${BASH_REMATCH[7]}"
                local serial="${BASH_REMATCH[8]}"
                local channel="${BASH_REMATCH[9]}"
                local device_num="${BASH_REMATCH[10]}"
                local model="${BASH_REMATCH[11]}"
                local size="${BASH_REMATCH[12]}"
                local match_method="${BASH_REMATCH[13]}"
                
                # Check if this matches our target position
                if [[ $rec_connector -eq $connector && $rec_device -eq $device ]]; then
                    # For unallocated drives, device_path might be "NONE"
                    if [[ "$device_path" == "NONE" ]]; then
                        device_path="/dev/unknown"
                    fi
                    
                    # Return the drive information
                    echo "$drive_name $device_path $model"
                    return 0
                fi
            fi
        fi
    done <<< "$unified_data"
    
    # No drive found at this position
    return 1
}

#================================================================
# Background Process Functions
#================================================================

#
# Start SnapRAID recovery operations in background
#
start_snapraid_recovery_background() {
    local target_drive="$1"
    
    # Load background process manager
    bootstrap_load_module pooltool/background/process_manager
    bootstrap_load_module pooltool/background/notifications
    
    local operation_id=$(pooltool::background::process_manager::generate_operation_id "drive-recovery")
    local log_dir="/var/log/pooltool"
    local log_file="${log_dir}/${operation_id}.log"
    
    # Ensure log directory exists
    mkdir -p "$log_dir" 2>/dev/null || {
        log_dir="${HOME}/.pooltool/logs"
        log_file="${log_dir}/${operation_id}.log"
        mkdir -p "$log_dir"
    }
    
    echo ""
    echo "üöÄ STARTING BACKGROUND RECOVERY"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Operation ID: $operation_id"
    echo "Target Drive: $target_drive"
    echo "Log File: $log_file"
    echo ""
    
    # Determine if this is a parity or data drive
    local command=""
    if [[ "$target_drive" =~ PPU[0-9]+ ]]; then
        echo "üìã Parity drive recovery process will:"
        echo "  1. Run 'snapraid sync' to rebuild parity"
        echo "  2. Run 'snapraid scrub' to verify integrity"
        command="this::snapraid_parity_recovery '$target_drive' '$operation_id'"
    else
        echo "üìã Data drive recovery process will:"
        echo "  1. Run 'snapraid fix -d $target_drive' to restore data"
        echo "  2. Run 'snapraid scrub -d $target_drive' to verify integrity"
        command="this::snapraid_data_recovery '$target_drive' '$operation_id'"
    fi
    
    echo ""
    echo "‚è±Ô∏è  Estimated time: 2-8 hours (depends on drive size and system)"
    echo "üìä Monitor progress: pooltool monitor show $operation_id"
    echo "üìã View live logs: pooltool monitor logs $operation_id --follow"
    echo ""
    
    if ! pooltool::question -p "Start background recovery process?" -d "y"; then
        echo "‚ùå Background recovery cancelled"
        return 1
    fi
    
    # Start the background process
    local started_id=$(pooltool::background::process_manager::start_background_process \
        "drive-recovery" \
        "$operation_id" \
        "$command" \
        "$log_file")
    
    if [[ -n "$started_id" ]]; then
        echo "‚úÖ Background recovery started successfully!"
        echo ""
        echo "üìã NEXT STEPS:"
        echo "  ‚Ä¢ Monitor: pooltool monitor show $operation_id"
        echo "  ‚Ä¢ Live logs: pooltool monitor logs $operation_id --follow"
        echo "  ‚Ä¢ Wait for completion: pooltool monitor wait $operation_id"
        echo ""
        echo "üîî You will be notified when the recovery completes."
        echo "   (Configure notifications in ~/.pooltool/notifications.conf)"
        
        # Send initial notification
        pooltool::background::notifications::send_notification \
            "$operation_id" \
            "started" \
            "medium" \
            "SnapRAID Recovery Started" \
            "Drive recovery for $target_drive has begun. This may take several hours."
            
        return 0
    else
        echo "‚ùå Failed to start background recovery"
        return 1
    fi
}

#
# SnapRAID data drive recovery process
#
snapraid_data_recovery() {
    local target_drive="$1"
    local operation_id="$2"
    
    echo "$(date): Starting data recovery for drive $target_drive" >&2
    echo "$(date): Running snapraid fix -d $target_drive" >&2
    
    # Update progress
    pooltool::background::process_manager::update_process_state \
        "$operation_id" "running" "Running snapraid fix" "" "25" "100"
    
    if snapraid fix -d "$target_drive"; then
        echo "$(date): SnapRAID fix completed successfully" >&2
        
        # Update progress
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "running" "Running snapraid scrub" "" "75" "100"
        
        echo "$(date): Running snapraid scrub -d $target_drive" >&2
        
        if snapraid scrub -d "$target_drive"; then
            echo "$(date): SnapRAID scrub completed successfully" >&2
            
            # Update to completed
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "completed" "Recovery completed successfully" "" "100" "100"
            
            # Send completion notification
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "completed"
            
            return 0
        else
            echo "$(date): SnapRAID scrub failed" >&2
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "failed" "SnapRAID scrub failed"
            
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "failed"
            
            return 1
        fi
    else
        echo "$(date): SnapRAID fix failed" >&2
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "failed" "SnapRAID fix failed"
        
        pooltool::background::notifications::notify_operation_complete \
            "$operation_id" "failed"
        
        return 1
    fi
}

#
# SnapRAID parity drive recovery process  
#
snapraid_parity_recovery() {
    local target_drive="$1"
    local operation_id="$2"
    
    echo "$(date): Starting parity recovery for drive $target_drive" >&2
    echo "$(date): Running snapraid sync" >&2
    
    # Update progress
    pooltool::background::process_manager::update_process_state \
        "$operation_id" "running" "Running snapraid sync" "" "25" "100"
    
    if snapraid sync; then
        echo "$(date): SnapRAID sync completed successfully" >&2
        
        # Update progress  
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "running" "Running snapraid scrub" "" "75" "100"
        
        echo "$(date): Running snapraid scrub" >&2
        
        if snapraid scrub; then
            echo "$(date): SnapRAID scrub completed successfully" >&2
            
            # Update to completed
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "completed" "Parity recovery completed successfully" "" "100" "100"
            
            # Send completion notification
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "completed"
            
            return 0
        else
            echo "$(date): SnapRAID scrub failed" >&2
            pooltool::background::process_manager::update_process_state \
                "$operation_id" "failed" "SnapRAID scrub failed"
            
            pooltool::background::notifications::notify_operation_complete \
                "$operation_id" "failed"
            
            return 1
        fi
    else
        echo "$(date): SnapRAID sync failed" >&2
        pooltool::background::process_manager::update_process_state \
            "$operation_id" "failed" "SnapRAID sync failed"
        
        pooltool::background::notifications::notify_operation_complete \
            "$operation_id" "failed"
        
        return 1
    fi
}

#
# Helper function to convert number to character
#
chr() {
    printf "\\$(printf '%03o' "$1")"
}

#
# Progress tracking functions for rsync operations
#
replace_rsync_progress_monitor() {
    local rsync_pid="$1"
    local source_path="$2"
    local target_path="$3"
    
    echo "üìä Monitoring rsync progress (PID: $rsync_pid)..."
    
    while kill -0 "$rsync_pid" 2>/dev/null; do
        # Monitor target directory size
        if [[ -d "$target_path" ]]; then
            local source_size=$(du -sb "$source_path" 2>/dev/null | cut -f1)
            local target_size=$(du -sb "$target_path" 2>/dev/null | cut -f1)
            
            if [[ -n "$source_size" && -n "$target_size" && $source_size -gt 0 ]]; then
                local percent=$((target_size * 100 / source_size))
                echo "Progress: ${percent}% copied ($(numfmt --to=iec $target_size) / $(numfmt --to=iec $source_size))"
            fi
        fi
        
        sleep 30
    done
    
    echo "‚úÖ Rsync process completed"
}

#
# Prompt user to select source drive when not specified on command line
#
replace_prompt_source_drive_selection() {
    echo "üíæ Available drives for upgrade:" >&2
    echo "" >&2
    
    # Show drives with health evaluation to help user choose
    echo "Getting drive information..." >&2
    local drive_list
    drive_list=$(cd /media/tRAID/local/src/pooltool && ./pooltool.sh health --evaluate --quiet 2>/dev/null)
    
    if [[ -n "$drive_list" ]]; then
        echo "" >&2
        echo "POSITION  DRIVE     SIZE       USAGE    RISK  RECOMMENDATION" >&2
        echo "--------  --------  ---------  -------  ----  --------------------------------" >&2
        echo "$drive_list" | head -10 >&2
        echo "" >&2
        echo "üí° Higher risk scores indicate better upgrade candidates" >&2
    else
        # Fallback to basic drive listing
        echo "" >&2
        cd /media/tRAID/local/src/pooltool && ./pooltool.sh drives 2>/dev/null | grep -E "^(DRU|PPU)[0-9]+" | head -10 >&2
        echo "" >&2
    fi
    
    echo "Selection options:" >&2
    echo "  ‚Ä¢ Enter a position number (1-24)" >&2
    echo "  ‚Ä¢ Enter a drive name (DRU01, PPU02, etc.)" >&2
    echo "  ‚Ä¢ Type 'visual' to use the visual drive selector" >&2
    echo "  ‚Ä¢ Type 'q' to quit" >&2
    echo "" >&2
    
    while true; do
        # Use stdin if available (for automation), otherwise use /dev/tty for interactive mode
        if [ -t 0 ]; then
            read -p "Select source drive to upgrade: " user_input </dev/tty
        else
            read -p "Select source drive to upgrade: " user_input
        fi
        
        case "$user_input" in
            "q"|"quit")
                return 1
                ;;
            "visual")
                echo "üéØ Opening visual drive selector..." >&2
                echo "üí° Select your source drive from the visual layout" >&2
                echo "" >&2
                
                # Call the visual drive selector
                cd /media/tRAID/local/src/pooltool && ./pooltool.sh drives select >&2
                local selector_exit_code=$?
                
                if [[ $selector_exit_code -eq 0 ]]; then
                    echo "" >&2
                    echo "‚úÖ Drive selected from visual interface" >&2
                    if [ -t 0 ]; then
                        read -p "Enter the position number from your selection: " position_input </dev/tty
                    else
                        read -p "Enter the position number from your selection: " position_input
                    fi
                    if [[ "$position_input" =~ ^[1-9]$|^1[0-9]$|^2[0-4]$ ]]; then
                        echo "$position_input"
                        return 0
                    else
                        echo "‚ùå Invalid position. Please enter 1-24" >&2
                        continue
                    fi
                else
                    echo "‚ùå Visual selection cancelled" >&2
                    continue
                fi
                ;;
            [1-9]|1[0-9]|2[0-4])
                # Valid position number
                echo "$user_input"
                return 0
                ;;
            DRU[0-9][0-9]|PPU[0-9][0-9])
                # Drive name - convert to position
                local position
                position=$(cd /media/tRAID/local/src/pooltool && ./pooltool.sh drives 2>/dev/null | grep "^$user_input" | awk '{print $NF}' | grep -o '[0-9]\+')
                if [[ -n "$position" ]]; then
                    echo "$position"
                    return 0
                else
                    echo "‚ùå Could not find position for drive $user_input" >&2
                    continue
                fi
                ;;
            "")
                echo "Please enter a selection" >&2
                ;;
            *)
                echo "‚ùå Invalid selection. Please enter:" >&2
                echo "   ‚Ä¢ Position number (1-24)" >&2
                echo "   ‚Ä¢ Drive name (DRU01, PPU02, etc.)" >&2 
                echo "   ‚Ä¢ 'visual' for visual selector" >&2
                echo "   ‚Ä¢ 'q' to quit" >&2
                ;;
        esac
    done
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Enhanced Rsync Functions for SSH Persistence and Better UX
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Foreground rsync with clean progress bar (Issue #3 fix)
replace_upgrade_rsync_foreground() {
    local source_path="$1"
    local temp_mountpoint="$2"
    local runid="$3"
    
    local start_time=$(date +%s)
    echo "‚è∞ Copy started at: $(date)"
    echo ""
    
    # Run rsync with clean progress bar (not file-by-file)
    echo "üì¶ Starting file transfer with progress monitoring..."
    if snown::sudo rsync -ah --info=progress2 --no-i-r "$source_path/" "$temp_mountpoint/"; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        local duration_human=$(date -u -d @$duration +"%-Hh %-Mm %-Ss")
        
        echo ""
        echo "‚úÖ Copy completed successfully!"
        echo "‚è∞ Duration: $duration_human" 
        echo "üìä Final size: $(du -sh "$temp_mountpoint" | cut -f1)"
        echo ""
        
        # Store completion info for workflow
        echo "rsync_success=true" > "/tmp/pooltool_rsync_${runid}.status"
        echo "rsync_duration=$duration_human" >> "/tmp/pooltool_rsync_${runid}.status"
        echo "rsync_size=$(du -sh "$temp_mountpoint" | cut -f1)" >> "/tmp/pooltool_rsync_${runid}.status"
        
        # Store rsync session info globally  
        REPLACE_RSYNC_RUNID="$runid"
        REPLACE_RSYNC_MOUNTPOINT="$temp_mountpoint"
        
        return 0
    else
        local rsync_exit=$?
        echo ""
        echo "‚ùå Copy failed with exit code: $rsync_exit"
        
        case $rsync_exit in
            1)  echo "üí° Syntax or usage error" ;;
            2)  echo "üí° Protocol incompatibility" ;;
            3)  echo "üí° Errors selecting input/output files" ;;
            5)  echo "üí° Error starting client-server protocol" ;;
            11) echo "üí° Error in file I/O - check disk space" ;;
            20) echo "üí° Interrupted by signal (Ctrl+C)" ;;
            23) echo "üí° Partial transfer due to error" ;;
            *)  echo "üí° See rsync man page for exit code meanings" ;;
        esac
        
        echo "rsync_success=false" > "/tmp/pooltool_rsync_${runid}.status"
        echo "rsync_exit_code=$rsync_exit" >> "/tmp/pooltool_rsync_${runid}.status"
        return 1
    fi
}

# Background rsync with SSH persistence (Issue #1 & #2 fix)
replace_upgrade_rsync_background() {
    local source_path="$1"
    local temp_mountpoint="$2"
    local runid="$3"
    
    # Create workflow state for persistence
    local workflow_id=$(workflow_engine::get_current_workflow_id)
    local state_dir="/tmp/pooltool_workflow_${workflow_id}"
    mkdir -p "$state_dir"
    
    local rsync_log="$state_dir/rsync_progress.log"
    local rsync_pid_file="$state_dir/rsync.pid"
    local mount_info="$state_dir/mount_info"
    local status_file="$state_dir/rsync_status"
    
    # Save mount and state info for resumption
    echo "source_path=$source_path" > "$mount_info"
    echo "temp_mountpoint=$temp_mountpoint" >> "$mount_info"
    echo "runid=$runid" >> "$mount_info"
    echo "started_at=$(date)" >> "$mount_info"
    
    # Create background rsync script with progress monitoring
    cat > "$state_dir/rsync_wrapper.sh" << 'EOF'
#!/bin/bash
source_path="$1"
temp_mountpoint="$2"
log_file="$3"
pid_file="$4"
status_file="$5"

# Record our PID
echo $$ > "$pid_file"
echo "running" > "$status_file"

# Function to handle cleanup on exit
cleanup() {
    echo "stopping" > "$status_file"
    echo "$(date '+%Y-%m-%d %H:%M:%S') Background rsync process stopping" >> "$log_file"
}
trap cleanup EXIT

# Run rsync with progress logging
echo "$(date '+%Y-%m-%d %H:%M:%S') Starting background rsync copy" >> "$log_file"
echo "$(date '+%Y-%m-%d %H:%M:%S') Source: $source_path" >> "$log_file"
echo "$(date '+%Y-%m-%d %H:%M:%S') Target: $temp_mountpoint" >> "$log_file"

if rsync -ah --info=progress2 --no-i-r "$source_path/" "$temp_mountpoint/" 2>&1 | \
    while IFS= read -r line; do
        echo "$(date '+%Y-%m-%d %H:%M:%S') $line" >> "$log_file"
        # Also track overall progress
        if [[ "$line" =~ ([0-9,]+)\ +([0-9]+%)\ +([0-9.]+[A-Za-z]+/s) ]]; then
            echo "progress_bytes=${BASH_REMATCH[1]}" > "${status_file}.progress"
            echo "progress_percent=${BASH_REMATCH[2]}" >> "${status_file}.progress"
            echo "progress_speed=${BASH_REMATCH[3]}" >> "${status_file}.progress"
            echo "last_update=$(date +%s)" >> "${status_file}.progress"
        fi
    done; then
    echo "completed" > "$status_file"
    echo "$(date '+%Y-%m-%d %H:%M:%S') Copy completed successfully" >> "$log_file"
    exit 0
else
    local exit_code=$?
    echo "failed" > "$status_file"
    echo "exit_code=$exit_code" >> "$status_file"
    echo "$(date '+%Y-%m-%d %H:%M:%S') Copy failed with exit code $exit_code" >> "$log_file"
    exit $exit_code
fi
EOF
    
    chmod +x "$state_dir/rsync_wrapper.sh"
    
    echo "üöÄ Starting background data copy..."
    echo "üìù Progress log: $rsync_log"
    echo "üÜî Workflow ID: $workflow_id"
    echo ""
    
    # Start background process
    nohup "$state_dir/rsync_wrapper.sh" "$source_path" "$temp_mountpoint" "$rsync_log" "$rsync_pid_file" "$status_file" > /dev/null 2>&1 &
    local wrapper_pid=$!
    
    # Wait a moment to ensure it started
    sleep 3
    if ! kill -0 "$wrapper_pid" 2>/dev/null; then
        echo "‚ùå Failed to start background rsync process"
        return 1
    fi
    
    echo "‚úÖ Background transfer started successfully"
    echo ""
    echo "üìã IMPORTANT: Background Process Management"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "The data copy is now running in the background."
    echo "You can safely disconnect from SSH."
    echo ""
    echo "üìä To monitor progress:"
    echo "   pooltool workflow progress $workflow_id"
    echo "   tail -f $rsync_log"
    echo ""
    echo "üîÑ To resume this workflow later:"
    echo "   pooltool workflow resume $workflow_id"
    echo ""
    echo "‚ö†Ô∏è  WORKFLOW WILL PAUSE after copy completes"
    echo "    You must resume to continue with drive swap"
    echo ""
    
    # Set workflow state for resumption  
    workflow_engine::set_step_state "data_copy" "background_running"
    workflow_engine::save_state "rsync_mode" "background"
    workflow_engine::save_state "rsync_log" "$rsync_log"
    workflow_engine::save_state "rsync_pid_file" "$rsync_pid_file"
    workflow_engine::save_state "mount_info_file" "$mount_info"
    workflow_engine::save_state "status_file" "$status_file"
    workflow_engine::save_state "state_dir" "$state_dir"
    
    # Store rsync session info globally for immediate workflow context
    REPLACE_RSYNC_RUNID="$runid"
    REPLACE_RSYNC_MOUNTPOINT="$temp_mountpoint"
    
    # Return special code to indicate background mode
    return 3  # Special return code for "background_started"
}
