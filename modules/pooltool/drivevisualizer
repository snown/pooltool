#!/usr/bin/env bash
NAMESPACE=pooltool

dependencies::depends "pooltool/driveutils"
dependencies::depends "pooltool/capacityutils"
dependencies::depends "pooltool/healthutils"
dependencies::register_module "pooltool/drivevisualizer"

# Generate system overview header with array status and health summary
#-------------------------------------------------------------------------------
function generate_system_overview_header {
    local unified_device_data=("$@")
    local use_colors="${1:-true}"
    
    # Initialize color scheme
    local GREEN="" YELLOW="" RED="" BLUE="" RESET=""
    if [[ "$use_colors" == "true" ]]; then
        GREEN=$'\033[32m'
        YELLOW=$'\033[33m' 
        RED=$'\033[91m'
        BLUE=$'\033[36m'
        RESET=$'\033[0m'
    fi
    
    # Collect system statistics
    local total_drives=0
    local allocated_drives=0
    local unallocated_drives=0
    local good_health=0
    local warning_health=0
    local critical_health=0
    local total_capacity=0
    local total_used=0
    local min_temp=999
    local max_temp=0
    local temp_readings=0
    local parity_drives=0
    local data_drives=0
    
    # Get health data efficiently for all drives
    local health_results
    if health_results=$(pooltool::get_all_health_info_efficient 1 "${unified_device_data[@]}" 2>/dev/null); then
        while IFS= read -r line; do
            if [[ "$line" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
                local mount_name="${BASH_REMATCH[1]}"
                local health_status="${BASH_REMATCH[14]}"
                local temperature="${BASH_REMATCH[15]}"
                local snapraid_name="${BASH_REMATCH[5]}"
                
                total_drives=$((total_drives + 1))
                
                # Count drive types
                if [[ "$mount_name" =~ ^PPU ]]; then
                    parity_drives=$((parity_drives + 1))
                elif [[ "$mount_name" =~ ^DRU ]]; then
                    data_drives=$((data_drives + 1))
                fi
                
                # Count allocation status
                if [[ "$mount_name" =~ ^(NEW-|UNALLOC) ]]; then
                    unallocated_drives=$((unallocated_drives + 1))
                else
                    allocated_drives=$((allocated_drives + 1))
                fi
                
                # Count health status
                case "$health_status" in
                    "good") good_health=$((good_health + 1)) ;;
                    "warning") warning_health=$((warning_health + 1)) ;;
                    "critical") critical_health=$((critical_health + 1)) ;;
                esac
                
                # Track temperature
                if [[ "$temperature" =~ ^[0-9]+$ && $temperature -gt 0 ]]; then
                    temp_readings=$((temp_readings + 1))
                    if [[ $temperature -lt $min_temp ]]; then
                        min_temp=$temperature
                    fi
                    if [[ $temperature -gt $max_temp ]]; then
                        max_temp=$temperature
                    fi
                fi
                
                # Get capacity data for allocated drives
                if [[ "$mount_name" =~ ^(DRU|PPU) ]]; then
                    local expected_mount="/mnt/${mount_name}"
                    if mountpoint -q "$expected_mount" 2>/dev/null; then
                        local df_output
                        if df_output=$(df -BG "$expected_mount" 2>/dev/null | tail -n1); then
                            local size_gb used_gb
                            size_gb=$(echo "$df_output" | awk '{print $2}' | tr -d 'G')
                            used_gb=$(echo "$df_output" | awk '{print $3}' | tr -d 'G')
                            if [[ "$size_gb" =~ ^[0-9]+$ && "$used_gb" =~ ^[0-9]+$ ]]; then
                                total_capacity=$((total_capacity + size_gb))
                                total_used=$((total_used + used_gb))
                            fi
                        fi
                    fi
                fi
            fi
        done <<< "$health_results"
    fi
    
    # Get SnapRAID status
    local snapraid_status="Unknown"
    local last_sync="Never"
    if command -v snapraid >/dev/null 2>&1; then
        # Try to get SnapRAID status (this might need adjustment based on actual snapraid output)
        if snapraid status >/dev/null 2>&1; then
            snapraid_status="${GREEN}Healthy${RESET}"
        else
            snapraid_status="${YELLOW}Check Needed${RESET}"
        fi
        
        # Try to find last sync time (this is a simplified approach)
        if [[ -f /var/log/snapraid.log ]]; then
            last_sync=$(grep -i "sync completed" /var/log/snapraid.log 2>/dev/null | tail -1 | awk '{print $1 " " $2}' 2>/dev/null || echo "Unknown")
        fi
    fi
    
    # Calculate percentages and formatting
    local usage_percent=0
    if [[ $total_capacity -gt 0 ]]; then
        usage_percent=$(( (total_used * 100) / total_capacity ))
    fi
    
    local avg_temp=0
    if [[ $temp_readings -gt 0 ]]; then
        # We'll approximate average as midpoint for now
        avg_temp=$(( (min_temp + max_temp) / 2 ))
    fi
    
    # Format capacity display
    local capacity_display
    if [[ $total_capacity -ge 1000 ]]; then
        local total_tb=$((total_capacity / 1000))
        local used_tb=$((total_used / 1000))
        capacity_display="${used_tb}.${total_tb}TB used"
    else
        capacity_display="${total_used}/${total_capacity}GB"
    fi
    
    # Health status colors
    local health_good="${GREEN}${good_health}✅${RESET}"
    local health_warn=""
    local health_crit=""
    if [[ $warning_health -gt 0 ]]; then
        health_warn=" ${YELLOW}${warning_health}⚠️${RESET}"
    fi
    if [[ $critical_health -gt 0 ]]; then
        health_crit=" ${RED}${critical_health}❌${RESET}"
    fi
    
    # Temperature display with color coding
    local temp_display=""
    if [[ $temp_readings -gt 0 ]]; then
        local temp_color=""
        if [[ $max_temp -gt 55 ]]; then
            temp_color="$RED"
        elif [[ $max_temp -gt 45 ]]; then
            temp_color="$YELLOW"
        else
            temp_color="$GREEN"
        fi
        temp_display=" │ Temp: ${temp_color}${min_temp}-${max_temp}°C${RESET}"
    fi
    
    # Generate header box
    local header_width=72
    local border_line=$(printf "%*s" $((header_width - 2)) "" | tr ' ' '─')
    
    echo "┌${border_line}┐"
    printf "│%*s%s%*s│\n" $(( (header_width - 20) / 2 )) "" "SnapRAID System Status" $(( (header_width - 20) / 2 )) ""
    echo "├${border_line}┤"
    
    # Array status line
    printf "│ Array: %s │ Health: %s%s%s │ %s%*s│\n" \
        "${allocated_drives}/${total_drives} drives" \
        "$health_good" "$health_warn" "$health_crit" \
        "$capacity_display" \
        $((header_width - 35 - ${#capacity_display})) ""
    
    # Status and temperature line  
    printf "│ Status: %s │ Last Sync: %-12s%s%*s│\n" \
        "$snapraid_status" \
        "$last_sync" \
        "$temp_display" \
        $((header_width - 45 - ${#last_sync})) ""
        
    echo "└${border_line}┘"
    echo ""
}

# Calculate position number from connector and device slot
#-------------------------------------------------------------------------------
function calculate_position_number {
    local connector="$1"
    local device="$2"
    
    # Position calculation: connector * 4 + (4 - device)
    # This gives us positions 1-24 for a 6x4 grid
    local position=$(( connector * 4 + (4 - device) ))
    echo "$position"
}

# Test function for the system overview header

# Initialize color scheme for visual display
#-------------------------------------------------------------------------------
function init_visual_colors {
    local use_colors="${1:-true}"
    
    # Global color variables (will be used by other functions)
    if [[ "$use_colors" == "true" ]]; then
        LED_OFF_COLOR=$'\033[2m'      # Dim gray
        LED_ON_COLOR=$'\033[32m'      # Green  
        LED_UNALLOCATED_COLOR=$'\033[33m'  # Yellow
        RESET_COLOR=$'\033[0m'        # Reset
        LED_OFF="${LED_OFF_COLOR}●${RESET_COLOR}"
        LED_ON="${LED_ON_COLOR}●${RESET_COLOR}"
        LED_UNALLOCATED="${LED_UNALLOCATED_COLOR}+${RESET_COLOR}"
    else
        LED_OFF_COLOR=""
        LED_ON_COLOR=""
        LED_UNALLOCATED_COLOR=""
        RESET_COLOR=""
        LED_OFF="○"                  # Open circle for non-blinking
        LED_ON="●"                   # Filled circle for blinking
        LED_UNALLOCATED="+"          # Plus sign for unallocated
    fi
}

# Calculate optimal label dimensions and grid sizing
#-------------------------------------------------------------------------------
function calculate_label_dimensions {
    local device_data=("$@")
    local label_type="${1:-mount}"
    shift
    local device_records=("$@")
    
    local max_label_length=0
    local current_length
    
    # Find the longest label in the selected category
    for record in "${device_records[@]}"; do
        local label=""
        
        # Parse record format: mount_name:arcconf_id:connector:device_slot:snapraid_name:system_device:wwn:serial:channel:device_num:model:size:match_method
        if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
            local mount_name="${BASH_REMATCH[1]}"
            local arcconf_id="${BASH_REMATCH[2]}"
            local connector="${BASH_REMATCH[3]}"
            local device_slot="${BASH_REMATCH[4]}"
            local snapraid_name="${BASH_REMATCH[5]}"
            local system_device="${BASH_REMATCH[6]}"
            
            case "$label_type" in
                "mount")
                    label="$mount_name"
                    ;;
                "snapraid")
                    label="${snapraid_name:-$mount_name}"
                    ;;
                "device")
                    # Remove /dev/ prefix from device path to match format_device_label
                    label="${system_device#/dev/}"
                    ;;
                "arcconf")
                    label="C${connector}D${device_slot}"
                    ;;
                *)
                    label="$mount_name"  # Default fallback
                    ;;
            esac
            
            current_length=${#label}
            if [[ $current_length -gt $max_label_length ]]; then
                max_label_length=$current_length
            fi
        fi
    done
    
    # Handle empty bays - they use "-----" pattern
    local empty_label_length=5  # Length of "-----"
    if [[ $empty_label_length -gt $max_label_length ]]; then
        max_label_length=$empty_label_length
    fi
    
    # Calculate dimensions
    local cell_width=$((max_label_length + 3))  # [label + space + indicator]
    local total_width=$((cell_width * 4 + 8))   # 4 cells + spacing between cells
    local box_width=$((total_width + 8))         # borders + internal padding
    
    # Output the calculated dimensions
    echo "DIMENSIONS:$max_label_length:$cell_width:$total_width:$box_width"
}

# Format individual device label with proper padding
#-------------------------------------------------------------------------------
function format_device_label {
    local record="$1"
    local label_type="$2"
    local max_width="$3"
    local status="${4:-available}"
    
    local label=""
    local indicator=""
    
    # Handle special case for empty slots
    if [[ "$record" == "EMPTY" ]]; then
        # Start the empty label with two '-' characters to account for the space taken by the indicator
        local empty_label="--"
        for ((i=0; i<max_width; i++)); do
            empty_label+="-"
        done
        echo "[$empty_label]"
        return
    fi
    
    # Parse record format
    if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
        local mount_name="${BASH_REMATCH[1]}"
        local arcconf_id="${BASH_REMATCH[2]}"
        local connector="${BASH_REMATCH[3]}"
        local device_slot="${BASH_REMATCH[4]}"
        local snapraid_name="${BASH_REMATCH[5]}"
        local system_device="${BASH_REMATCH[6]}"
        
        case "$label_type" in
            "mount")
                label="$mount_name"
                ;;
            "snapraid")
                label="${snapraid_name:-$mount_name}"
                ;;
            "device")
                # Remove /dev/ prefix from device path
                label="${system_device#/dev/}"
                ;;
            "arcconf")
                label="C${connector}D${device_slot}"
                ;;
            *)
                label="$mount_name"  # Default fallback
                ;;
        esac
        
        # Set indicator based on status
        case "$status" in
            "blinking")
                indicator=" ${LED_ON}"
                ;;
            "available")
                indicator=" ${LED_OFF}"
                ;;
            "unallocated")
                # Use a different indicator for unallocated drives (drives detected by arcconf but not in snapraid)
                indicator=" ${LED_UNALLOCATED}"
                ;;
            *)
                indicator=" ${LED_OFF}"
                ;;
        esac
        
        # Pad label to max width
        local padded_label="$label"
        while [[ ${#padded_label} -lt $max_width ]]; do
            padded_label+=" "
        done
        
        echo "[$padded_label$indicator]"
    else
        # Fallback for unparseable records
        local padded_label="UNKNOWN"
        while [[ ${#padded_label} -lt $max_width ]]; do
            padded_label+=" "
        done
        echo "[$padded_label ${LED_OFF}]"
    fi
}

# Render complete ASCII drive grid
#-------------------------------------------------------------------------------
function render_drive_grid {
    local physical_layout_data="$1"
    local label_type="${2:-mount}"
    local blinking_devices_str="${3:-}"
    local use_colors="${4:-true}"
    local unified_device_data=("${@:5}")  # Remaining args are unified device records
    
    # Initialize colors
    pooltool::init_visual_colors "$use_colors"
    
    # Parse blinking devices
    local -A is_blinking
    if [[ -n "$blinking_devices_str" ]]; then
        IFS=',' read -ra blinking_array <<< "$blinking_devices_str"
        for device_id in "${blinking_array[@]}"; do
            is_blinking["$device_id"]=1
        done
    fi
    
    # Parse physical layout data to extract position, device name, and status
    local -A layout_by_position
    local -A status_by_position
    
    # Skip the "PHYSICAL_LAYOUT:" header and process the layout rows
    local in_layout=false
    local connector_index=0
    while IFS= read -r line; do
        if [[ "$line" == "PHYSICAL_LAYOUT:" ]]; then
            in_layout=true
            continue
        fi
        
        if [[ "$in_layout" == true && -n "$line" ]]; then
            # Parse layout row: "device1:status1 device2:status2 device3:status3 device4:status4"
            # The order in the line is: device3, device2, device1, device0 (left to right in the display)
            
            # Use read to split the line into device:status pairs
            read -ra device_pairs <<< "$line"
            local device_index=3  # Start from device 3
            for device_pair in "${device_pairs[@]}"; do
                if [[ "$device_pair" =~ ^([^:]+):(.+)$ ]]; then
                    local device_name="${BASH_REMATCH[1]}"
                    local device_status="${BASH_REMATCH[2]}"
                    
                    local position_key="${connector_index}_${device_index}"
                    layout_by_position["$position_key"]="$device_name"
                    status_by_position["$position_key"]="$device_status"
                    
                    ((device_index--))
                fi
            done
            ((connector_index++))
        fi
    done <<< "$physical_layout_data"
    
    # Create device lookup by position for label resolution
    local -A device_by_position
    for record in "${unified_device_data[@]}"; do
        if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+): ]]; then
            local mount_name="${BASH_REMATCH[1]}"
            local arcconf_id="${BASH_REMATCH[2]}"
            local connector="${BASH_REMATCH[3]}"
            local device_slot="${BASH_REMATCH[4]}"
            
            local position_key="${connector}_${device_slot}"
            device_by_position["$position_key"]="$record"
        fi
    done
    
    # Calculate label dimensions
    local dimensions_output
    dimensions_output=$(pooltool::calculate_label_dimensions "$label_type" "${unified_device_data[@]}")
    
    if [[ "$dimensions_output" =~ ^DIMENSIONS:([^:]+):([^:]+):([^:]+):([^:]+)$ ]]; then
        local max_label_length="${BASH_REMATCH[1]}"
        local cell_width="${BASH_REMATCH[2]}"
        local total_width="${BASH_REMATCH[3]}"
        local box_width="${BASH_REMATCH[4]}"
    else
        # Fallback dimensions
        local max_label_length=8
        local cell_width=12
        local total_width=56
        local box_width=64
    fi
    
    # Create top border
    local border_line=""
    for ((i=0; i<box_width; i++)); do
        border_line+="─"
    done

    # Create Title
    local title="Physical Drive Bay Layout"
    local title_padding=$(( (box_width - ${#title}) ))
    local left_padding=$(( title_padding / 2 ))
    local right_padding=$(( title_padding - left_padding ))
    local padded_title=$(printf "%*s" $left_padding "" )"$title"$(printf "%*s" $right_padding "" )

    # Render the grid
    echo
    echo "┌${border_line}┐"
    echo "│$padded_title│"
    echo "├${border_line}┤"
    echo "│$(printf "%*s" $((box_width)) "")│"
    
    # Render each row (connector 0-5)
    for connector in {0..5}; do
        local row_output="│  "
        
        # Render each column (device 3,2,1,0 - right to left)
        for device in 3 2 1 0; do
            local position_key="${connector}_${device}"
            local device_name="${layout_by_position[$position_key]:-EMPTY}"
            local device_status="${status_by_position[$position_key]:-empty}"
            local device_record="${device_by_position[$position_key]:-}"
            
            # Check if this device is blinking (overrides other status)
            if [[ -n "$device_record" && "$device_record" =~ ^([^:]+):([^:]+): ]]; then
                local mount_name="${BASH_REMATCH[1]}"
                local arcconf_id="${BASH_REMATCH[2]}"
                
                if [[ -n "${is_blinking[$arcconf_id]}" ]]; then
                    device_status="blinking"
                fi
            fi
            
            # For formatting, we need either the device record or a dummy record for empty/unallocated
            local format_record="$device_record"
            if [[ -z "$format_record" ]]; then
                # Create a dummy record for empty or unallocated devices
                format_record="$device_name::::::::::::::"
            fi
            
            local formatted_cell
            formatted_cell=$(pooltool::format_device_label "$format_record" "$label_type" "$max_label_length" "$device_status")
            row_output+="$formatted_cell  "
        done
        
        echo "$row_output  │"
    done
    
    echo "│$(printf "%*s" $((box_width)) "")│"
    
    # Legend with proper padding
    local legend_line
    
    legend_line="│  Legend:"
    printf -v padding "%*s" $((box_width - ${#legend_line} - 1)) ""
    echo "${legend_line}${padding}  │"
    
    local legend_key_length=10 # The space of a typical legend entry from left padding to the start of the label. This should stay relatively consistent, so we hard code it here. _Note:_ It does not include the left border character.
    local legend_label="Blinking"
    legend_line="│    [${LED_ON}] = ${legend_label}"
    printf -v padding "%*s" $((box_width - (legend_key_length + ${#legend_label}))) ""
    echo "${legend_line}${padding}│"

    legend_label="Available"
    legend_line="│    [${LED_OFF}] = ${legend_label}"
    printf -v padding "%*s" $((box_width - (legend_key_length + ${#legend_label}))) ""
    echo "${legend_line}${padding}│"

    legend_label="Unallocated"
    legend_line="│    [${LED_UNALLOCATED}] = ${legend_label}"
    printf -v padding "%*s" $((box_width - (legend_key_length + ${#legend_label}))) ""
    echo "${legend_line}${padding}│"

    legend_label="Empty"
    legend_line="│    [-] = ${legend_label}"
    printf -v padding "%*s" $((box_width - ${#legend_line} - 1)) ""
    echo "${legend_line}${padding}  │"

    echo "│$(printf "%*s" $((box_width)) "")│"
    echo "│  DRU = Data drive, PPU = Parity drive$(printf "%*s" $((box_width-40)) "")  │"
    echo "└${border_line}┘"
}

# Simple visual display function for quick testing
#-------------------------------------------------------------------------------
function show_drive_layout_simple {
    local unified_data=("$@")
    local label_type="mount"
    local blinking_devices=""
    local use_colors="true"
    
    # Convert unified data to the format expected by render_drive_grid
    pooltool::render_drive_grid "PHYSICAL_LAYOUT" "$label_type" "$blinking_devices" "$use_colors" "${unified_data[@]}"
}

# Debug function for testing visualization
#-------------------------------------------------------------------------------
function debug_visualization {
    local controller="${1:-1}"
    local label_type="${2:-mount}"
    local use_colors="${3:-true}"
    
    echo "=== Debug: Drive Visualizer Module ===" >&2
    echo >&2
    
    # Get unified device data
    local unified_data
    if unified_data=$(pooltool::create_unified_mapping "$controller" 2>/dev/null); then
        readarray -t unified_array <<< "$unified_data"
        
        echo "--- Rendering Grid with Label Type: $label_type ---" >&2
        pooltool::show_drive_layout_simple "${unified_array[@]}"
        
        echo >&2
        echo "--- Testing Different Label Types ---" >&2
        for test_label in "mount" "snapraid" "device" "arcconf"; do
            echo "Testing label type: $test_label" >&2
            pooltool::render_drive_grid "PHYSICAL_LAYOUT" "$test_label" "" "$use_colors" "${unified_array[@]}"
            echo >&2
        done
    else
        echo "Failed to get unified device data" >&2
        return 1
    fi
}

# Enhanced render function with capacity and health information
#-------------------------------------------------------------------------------
function render_drive_grid_enhanced {
    local physical_layout_data="$1"
    local label_type="${2:-mount}"
    local blinking_devices="$3"
    local use_colors="${4:-true}"
    local show_capacity="${5:-false}"
    local show_health="${6:-false}"
    local show_overview="${7:-false}"
    local show_numbered="${8:-false}"
    shift 8
    local unified_device_data=("$@")
    
    # Initialize colors
    pooltool::init_visual_colors "$use_colors"
    
    # Get capacity and health information if requested
    local -A capacity_info
    local -A health_info
    local overview_data=""
    
    if [[ "$show_capacity" == "true" ]]; then
        # Get capacity data for all devices - simplified inline version
        for record in "${unified_device_data[@]}"; do
            # Parse record format: mount_name:arcconf_id:connector:device_slot:snapraid_name:system_device:wwn:serial:channel:device_num:model:size:match_method
            if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
                local mount_name="${BASH_REMATCH[1]}"
                local system_device="${BASH_REMATCH[6]}"
                
                if [[ "$mount_name" != "N/A" && "$system_device" != "N/A" ]]; then
                    # Try to find mount point for this device - use actual mount naming convention
                    local expected_mount="/mnt/${mount_name}"
                    if mountpoint -q "$expected_mount" 2>/dev/null; then
                        # Get df info for mounted drive
                        local df_output
                        if df_output=$(df -h "$expected_mount" 2>/dev/null | tail -n1); then
                            # Parse df output to get usage percentage
                            local use_percent_raw
                            use_percent_raw=$(echo "$df_output" | awk '{print $5}' | tr -d '%')
                            if [[ "$use_percent_raw" =~ ^[0-9]+$ ]]; then
                                capacity_info["$mount_name"]="mounted:${use_percent_raw}"
                            fi
                        fi
                    fi
                fi
            fi
        done
    fi
    
    if [[ "$show_health" == "true" ]]; then
        # Get health data for all devices
        for record in "${unified_device_data[@]}"; do
            if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):([^:]+):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)$ ]]; then
                local mount_name="${BASH_REMATCH[1]}"
                local system_device="${BASH_REMATCH[6]}"
                
                if [[ "$mount_name" != "N/A" && "$system_device" != "N/A" ]]; then
                    local health_status
                    health_status=$(pooltool::get_drive_health "$system_device")
                    health_info["$mount_name"]="$health_status"
                fi
            fi
        done
    fi
    
    # Calculate dimensions based on capacity display
    local max_label_length=8   # Standard label length like the original  
    local cell_width=14        # Slightly wider for capacity bars
    local total_width=64       # More reasonable total width
    local box_width=68         # More reasonable box width
    
    if [[ "$show_capacity" == "true" ]]; then
        cell_width=16          # Extra space for capacity bars
        total_width=68
        box_width=72
    fi
    
    # Create layout mapping
    local -A layout_by_position
    local -A status_by_position
    
    # Skip the "PHYSICAL_LAYOUT:" header and process the layout rows
    local in_layout=false
    local connector_index=0
    while IFS= read -r line; do
        if [[ "$line" == "PHYSICAL_LAYOUT:" ]]; then
            in_layout=true
            continue
        fi
        
        if [[ "$in_layout" == true && -n "$line" ]]; then
            read -ra device_pairs <<< "$line"
            local device_index=3
            for device_pair in "${device_pairs[@]}"; do
                if [[ "$device_pair" =~ ^([^:]+):(.+)$ ]]; then
                    local device_name="${BASH_REMATCH[1]}"
                    local device_status="${BASH_REMATCH[2]}"
                    
                    local position_key="${connector_index}_${device_index}"
                    layout_by_position["$position_key"]="$device_name"
                    status_by_position["$position_key"]="$device_status"
                    
                    ((device_index--))
                fi
            done
            ((connector_index++))
        fi
    done <<< "$physical_layout_data"
    
    # Create device lookup by position
    local -A device_by_position
    for record in "${unified_device_data[@]}"; do
        if [[ "$record" =~ ^([^:]+):([^:]+):([^:]+):([^:]+): ]]; then
            local mount_name="${BASH_REMATCH[1]}"
            local connector="${BASH_REMATCH[3]}"
            local device_slot="${BASH_REMATCH[4]}"
            
            local position_key="${connector}_${device_slot}"
            device_by_position["$position_key"]="$record"
        fi
    done
    
    # Build border
    local border_line=""
    for ((i=0; i<box_width; i++)); do
        border_line+="─"
    done
    
    # Show system overview if requested
    if [[ "$show_overview" == "true" ]]; then
        generate_system_overview_header "${unified_device_data[@]}"
    fi
    
    # Header
    if [[ "$show_overview" != "true" ]]; then
        echo "┌${border_line}┐"
    fi
    
    local title="Physical Drive Bay Layout"
    if [[ "$show_capacity" == "true" && "$show_health" == "true" ]]; then
        title="Drive Layout with Capacity & Health"
    elif [[ "$show_capacity" == "true" ]]; then
        title="Drive Bay Layout with Capacity"
    elif [[ "$show_health" == "true" ]]; then
        title="Drive Bay Layout with Health"
    fi
    
    # Add numbered indicator to title
    if [[ "$show_numbered" == "true" ]]; then
        title="$title (Numbered)"
    fi
    
    local title_padding=$(( (box_width - ${#title}) / 2 ))
    printf "│%*s%s%*s│\n" $title_padding "" "$title" $((box_width - title_padding - ${#title})) ""
    echo "├${border_line}┤"
    
    # Render grid with capacity information
    for connector in {0..5}; do
        local row_parts=()
        
        for device in {3..0}; do
            local position_key="${connector}_${device}"
            local device_name="${layout_by_position[$position_key]}"
            local device_status="${status_by_position[$position_key]}"
            local device_record="${device_by_position[$position_key]}"
            
            if [[ -n "$device_name" && "$device_name" != "N/A" ]]; then
                # For formatting, we need either the device record or a dummy record for empty/unallocated
                local format_record="$device_record"
                if [[ -z "$format_record" ]]; then
                    # Create a dummy record for empty or unallocated devices
                    format_record="$device_name::::::::::::::"
                fi
                
                # Determine device status for the formatter
                local format_status="available"
                if [[ -n "$blinking_devices" && "$blinking_devices" =~ (^|,)${device_name}(,|$) ]]; then
                    format_status="blinking"
                elif [[ "$device_status" == "unallocated" ]]; then
                    format_status="unallocated"
                fi
                
                # Get the formatted cell using the standard formatter
                local cell_content
                cell_content=$(pooltool::format_device_label "$format_record" "$label_type" "$max_label_length" "$format_status")
                
                # Add capacity bar if enabled and available - insert it inside the brackets
                if [[ "$show_capacity" == "true" && -n "${capacity_info[$device_name]}" ]]; then
                    local cap_info="${capacity_info[$device_name]}"
                    if [[ "$cap_info" =~ ^([^:]+):([^:]+)$ ]]; then
                        local mount_status="${BASH_REMATCH[1]}"
                        local use_percent="${BASH_REMATCH[2]}"
                        
                        if [[ "$mount_status" == "mounted" ]]; then
                            # Generate compact usage bar (4 characters)
                            local bar_width=4
                            local filled_blocks=$((use_percent * bar_width / 100))
                            local empty_blocks=$((bar_width - filled_blocks))
                            
                            # Choose color based on usage
                            local bar_color=""
                            local reset_color=""
                            if [[ "$use_colors" == "true" ]]; then
                                reset_color=$'\033[0m'
                                if [[ $use_percent -ge 85 ]]; then
                                    bar_color=$'\033[91m'  # Bright red
                                elif [[ $use_percent -ge 70 ]]; then
                                    bar_color=$'\033[33m'  # Yellow
                                else
                                    bar_color=$'\033[32m'  # Green
                                fi
                            fi
                            
                            # Build the compact bar
                            local capacity_bar=""
                            for ((i=0; i<filled_blocks; i++)); do
                                capacity_bar+="▓"
                            done
                            for ((i=0; i<empty_blocks; i++)); do
                                capacity_bar+="░"
                            done
                            capacity_bar="${bar_color}${capacity_bar}${reset_color}"
                            
                            # Insert capacity bar into the cell: [DRU03   ●] becomes [DRU03 ▓▓▓░ ●]
                            cell_content=$(echo "$cell_content" | sed "s/   / $capacity_bar /")
                        fi
                    fi
                fi
                
                # Add health indicator if enabled and available
                if [[ "$show_health" == "true" && -n "${health_info[$device_name]}" ]]; then
                    local health_data="${health_info[$device_name]}"
                    if [[ "$health_data" =~ ^([^:]+): ]]; then
                        local health_status="${BASH_REMATCH[1]}"
                        local health_indicator
                        health_indicator=$(pooltool::get_health_indicator "$health_status" "$use_colors")
                        
                        # Insert health indicator before the closing bracket: [DRU03 ●] becomes [DRU03 ●✅]
                        cell_content=$(echo "$cell_content" | sed "s/]/$health_indicator]/")
                    fi
                fi
                
                # Add position numbering if enabled
                if [[ "$show_numbered" == "true" ]]; then
                    # Position calculation: connector * 4 + (4 - device)
                    local position_num=$(( connector * 4 + (4 - device) ))
                    # Prepend position number: [DRU03 ●] becomes 1[DRU03 ●]
                    cell_content="${position_num}${cell_content}"
                fi
            else
                # Handle empty bay using standard formatter
                local empty_record="EMPTY::::::::::::::"
                cell_content=$(pooltool::format_device_label "$empty_record" "$label_type" "$max_label_length" "empty")
                
                # Add position numbering for empty bays too
                if [[ "$show_numbered" == "true" ]]; then
                    # Position calculation: connector * 4 + (4 - device)
                    local position_num=$(( connector * 4 + (4 - device) ))
                    cell_content="${position_num}${cell_content}"
                fi
            fi
            
            row_parts+=("$cell_content")
        done
        
        # Print row
        printf "│  %s  %s  %s  %s  │\n" "${row_parts[@]}"
        
        # Add spacing between rows
        if [[ $connector -lt 5 ]]; then
            echo "│$(printf "%*s" $((box_width)) "")│"
        fi
    done
    
    # Footer with legend
    echo "├${border_line}┤"
    echo "│  ● = Drive present   + = Unallocated   - = Empty bay           │"
    
    if [[ "$show_capacity" == "true" ]]; then
        echo "│  Capacity: ▓▓▓░ (Green <70%, Yellow 70-85%, Red >85%)       │"
    fi
    
    if [[ "$show_health" == "true" ]]; then
        echo "│  Health: ✅=Good ⚠️=Warning ❌=Critical ◐=No SMART ◯=Unknown  │"
    fi
    
    echo "│  DRU = Data drive, PPU = Parity drive                      │"
    echo "└${border_line}┘"
}

# Test function for the system overview header
#-------------------------------------------------------------------------------
function test_system_overview_header {
    local controller="${1:-0}"
    
    echo "Testing System Overview Header..."
    echo "================================"
    
    # Get unified device data
    local unified_data
    if unified_data=$(pooltool::create_unified_mapping "$controller" 2>/dev/null); then
        readarray -t unified_array <<< "$unified_data"
        
        echo "Generating system overview header:"
        echo
        generate_system_overview_header "${unified_array[@]}"
        echo
        echo "Header test complete!"
    else
        echo "Failed to get unified device data"
        return 1
    fi
}
